<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>祥说</title>
  
  <subtitle>编程与学习</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://s.bixuebihui.cn/"/>
  <updated>2019-09-08T07:16:02.037Z</updated>
  <id>http://s.bixuebihui.cn/</id>
  
  <author>
    <name>Yujiaao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Graphviz node shapes</title>
    <link href="http://s.bixuebihui.cn/2019/09/08/Graphviz-node-shapes/"/>
    <id>http://s.bixuebihui.cn/2019/09/08/Graphviz-node-shapes/</id>
    <published>2019-09-08T06:23:23.000Z</published>
    <updated>2019-09-08T07:16:02.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-Shapes-结点形状"><a href="#Node-Shapes-结点形状" class="headerlink" title="Node Shapes  结点形状"></a>Node Shapes  结点形状</h1><hr><p>There are three main types of shapes : <a href="https://www.graphviz.org/doc/info/shapes.html#polygon" target="_blank" rel="noopener">polygon-based</a>, <a href="https://www.graphviz.org/doc/info/shapes.html#record" target="_blank" rel="noopener">record-based</a> and <a href="https://www.graphviz.org/doc/info/shapes.html#epsf" target="_blank" rel="noopener">user-defined</a>. The record-based shape has largely been superseded and greatly generalized by <a href="https://www.graphviz.org/doc/info/shapes.html#html" target="_blank" rel="noopener">HTML-like labels</a>. That is, instead of using shape=record, one might consider using shape=none, margin=0 and an HTML-like label. </p><p>The geometry and style of all node shapes are affected by the node attributes <a href="https://www.graphviz.org/doc/info/attrs.html#d:fixedsize" target="_blank" rel="noopener">fixedsize</a>, <a href="https://www.graphviz.org/doc/info/attrs.html#d:fontname" target="_blank" rel="noopener">fontname</a>, <a href="https://www.graphviz.org/doc/info/attrs.html#d:fontsize" target="_blank" rel="noopener">fontsize</a>, <a href="https://www.graphviz.org/doc/info/attrs.html#d:height" target="_blank" rel="noopener">height</a>, <a href="https://www.graphviz.org/doc/info/attrs.html#d:label" target="_blank" rel="noopener">label</a>, <a href="#d:style">style</a> and <a href="https://www.graphviz.org/doc/info/attrs.html#d:width" target="_blank" rel="noopener">width</a>. </p><p>主要有三种类型的形状： 多边形为主， 基于记录和 用户自定义。基于记录的形状在很大程度上被取代，并且被类似HTML的标签大大推广。也就是说，可以考虑使用shape = none，margin = 0和类似HTML的标签，而不是使用shape = record。<br>所有节点形状的几何和样式都受节点属性 fixedsize， fontname， fontsize， height， label， style和 width的影响。</p><h2 id="Polygon-based-Nodes-基于多边形的节点"><a href="#Polygon-based-Nodes-基于多边形的节点" class="headerlink" title="Polygon-based Nodes 基于多边形的节点"></a>Polygon-based Nodes 基于多边形的节点</h2><p>可能的基于多边形的形状显示如下</p><p><img src="https://www.graphviz.org/doc/info/box.gif" alt="box"> <img src="https://www.graphviz.org/doc/info/polygon.gif" alt="polygon"> <img src="https://www.graphviz.org/doc/info/ellipse.gif" alt="ellipse"> <img src="https://www.graphviz.org/doc/info/oval.gif" alt></p><p>box polygon ellipse oval</p><p><img src="https://www.graphviz.org/doc/info/circle.gif" alt> <img src="https://www.graphviz.org/doc/info/point.gif" alt> <img src="https://www.graphviz.org/doc/info/egg.gif" alt> <img src="https://www.graphviz.org/doc/info/triangle.gif" alt><br>circle point egg triangle</p><p><img src="https://www.graphviz.org/doc/info/plaintext.gif" alt> <img src="https://www.graphviz.org/doc/info/plain.gif" alt> <img src="https://www.graphviz.org/doc/info/diamond.gif" alt> <img src="https://www.graphviz.org/doc/info/trapezium.gif" alt></p><p>plaintext plain diamond trapezium </p><p><img src="https://www.graphviz.org/doc/info/parallelogram.gif" alt> <img src="https://www.graphviz.org/doc/info/house.gif" alt> <img src="https://www.graphviz.org/doc/info/pentagon.gif" alt> <img src="https://www.graphviz.org/doc/info/hexagon.gif" alt> </p><p>parallelogram house pentagon hexagon</p><p><img src="https://www.graphviz.org/doc/info/septagon.gif" alt> <img src="https://www.graphviz.org/doc/info/octagon.gif" alt> <img src="https://www.graphviz.org/doc/info/doublecircle.gif" alt> <img src="https://www.graphviz.org/doc/info/doubleoctagon.gif" alt></p><p>septagon octagon doublecircle doubleoctagon</p><p><img src="https://www.graphviz.org/doc/info/tripleoctagon.gif" alt> <img src="https://www.graphviz.org/doc/info/invtriangle.gif" alt> <img src="https://www.graphviz.org/doc/info/invtrapezium.gif" alt> <img src="https://www.graphviz.org/doc/info/invhouse.gif" alt></p><p>tripleoctagon invtriangle invtrapezium invhouse</p><p><img src="https://www.graphviz.org/doc/info/Mdiamond.gif" alt> <img src="https://www.graphviz.org/doc/info/Msquare.gif" alt> <img src="https://www.graphviz.org/doc/info/Mcircle.gif" alt> <img src="https://www.graphviz.org/doc/info/rect.gif" alt></p><p>Mdiamond Msquare Mcircle rect</p><p><img src="https://www.graphviz.org/doc/info/rectangle.gif" alt> <img src="https://www.graphviz.org/doc/info/square.gif" alt> <img src="https://www.graphviz.org/doc/info/star.gif" alt> <img src="https://www.graphviz.org/doc/info/none.gif" alt></p><p>rectangle square star none</p><p><img src="https://www.graphviz.org/doc/info/underline.gif" alt> <img src="https://www.graphviz.org/doc/info/cylinder.gif" alt> <img src="https://www.graphviz.org/doc/info/note.gif" alt> <img src="https://www.graphviz.org/doc/info/tab.gif" alt></p><p>underline cylinder note tab</p><p><img src="https://www.graphviz.org/doc/info/folder.gif" alt> <img src="https://www.graphviz.org/doc/info/box3d.gif" alt> <img src="https://www.graphviz.org/doc/info/component.gif" alt> <img src="https://www.graphviz.org/doc/info/promoter.gif" alt></p><p>folder box3d component promoter</p><p><img src="https://www.graphviz.org/doc/info/cds.gif" alt> <img src="https://www.graphviz.org/doc/info/terminator.gif" alt> <img src="https://www.graphviz.org/doc/info/utr.gif" alt> <img src="https://www.graphviz.org/doc/info/primersite.gif" alt></p><p>cds terminator utrprimer site</p><p><img src="https://www.graphviz.org/doc/info/restrictionsite.gif" alt> <img src="https://www.graphviz.org/doc/info/fivepoverhang.gif" alt> <img src="https://www.graphviz.org/doc/info/threepoverhang.gif" alt> <img src="https://www.graphviz.org/doc/info/noverhang.gif" alt></p><p>restriction site fivepoverhang threepoverhang noverhang<br><img src="https://www.graphviz.org/doc/info/assembly.gif" alt> <img src="https://www.graphviz.org/doc/info/signature.gif" alt> <img src="https://www.graphviz.org/doc/info/insulator.gif" alt> <img src="https://www.graphviz.org/doc/info/ribosite.gif" alt></p><p>assembly signature insulator ribosite<br><img src="https://www.graphviz.org/doc/info/rnastab.gif" alt> <img src="https://www.graphviz.org/doc/info/proteasesite.gif" alt> <img src="https://www.graphviz.org/doc/info/proteinstab.gif" alt> <img src="https://www.graphviz.org/doc/info/rpromoter.gif" alt></p><p>rnastab protease site proteinstab rpromoter<br><img src="https://www.graphviz.org/doc/info/rarrow.gif" alt> <img src="https://www.graphviz.org/doc/info/larrow.gif" alt> <img src="https://www.graphviz.org/doc/info/lpromoter.gif" alt> </p><p>rarrow larrow lpromoter</p><p>如图所示，矩形和矩形是box的同义词，没有一个是明文的同义词。shape plain类似于这两个，除了它还强制 width = 0 height = 0 margin = 0，这保证了节点的实际大小完全由标签决定。例如，当使用类似HTML的标签时，这很有用。此外，与其余部分不同，我们已经显示了这三个以及下划线，没有style =填充 以指示正常使用。如果打开填充，标签文本将显示在填充矩形中。</p><p>As the figures suggest, the shapes rect and rectangle are synonyms for box, and none is a synonym for plaintext. The shape plain is similar to these two, except that it also enforces width=0 height=0 margin=0, which guarantees that the actual size of the node is entirely determined by the label. This is useful, for example, when using <a href="https://www.graphviz.org/doc/info/shapes.html#html" target="_blank" rel="noopener">HTML-like labels</a>. Also, unlike the rest, we have shown these three, as well as underline, without style=filled to indicate the normal use. If fill were turned on, the label text would appear in a filled rectangle. </p><p>基于多边形的形状的几何形状也受节点属性 规则， 周边和 方向的影响。如果shape =“polygon”，则还使用属性 side， skew和 distortion。如果未设置，则分别默认为4,0.0和0.0。点形状的特殊之处在于它仅受周边， 宽度和 高度属性的影响。</p><p>The geometries of polygon-based shapes are also affected by the node attributes <a href="https://www.graphviz.org/doc/info/attrs.html#d:regular" target="_blank" rel="noopener">regular</a>, <a href="https://www.graphviz.org/doc/info/attrs.html#d:peripheries" target="_blank" rel="noopener">peripheries</a> and <a href="https://www.graphviz.org/doc/info/attrs.html#d:orientation" target="_blank" rel="noopener">orientation</a>. If shape=”polygon”, the attributes <a href="https://www.graphviz.org/doc/info/attrs.html#d:sides" target="_blank" rel="noopener">sides</a>, <a href="https://www.graphviz.org/doc/info/attrs.html#d:skew" target="_blank" rel="noopener">skew</a> and <a href="https://www.graphviz.org/doc/info/attrs.html#d:distortion" target="_blank" rel="noopener">distortion</a> are also used. If unset, they default to 4, 0.0 and 0.0, respectively. The point shape is special in that it is only affected by the <a href="https://www.graphviz.org/doc/info/attrs.html#d:peripheries" target="_blank" rel="noopener">peripheries</a>, <a href="https://www.graphviz.org/doc/info/attrs.html#d:width" target="_blank" rel="noopener">width</a> and <a href="https://www.graphviz.org/doc/info/attrs.html#d:height" target="_blank" rel="noopener">height</a> attributes. </p><p>通常，节点的大小由包含其标签和图像所需的最小宽度和高度（如果有）确定，并具有由margin属性指定的边距。宽度和高度也必须至少与width和 height属性指定的大小一样大，这些 属性指定这些参数的最小值。有关限制节点大小的方法，请参阅fixedsize属性。特别是，如果fixedsize = shape，节点的形状将由width和 height属性固定，并且形状用于边缘终止，但是使用形状和标签大小来防止节点重叠。例如，下图</p><p>Normally, the size of a node is determined by smallest width and height needed to contain its label and image, if any, with a margin specified by the <a href="https://www.graphviz.org/doc/info/attrs.html#d:margin" target="_blank" rel="noopener">margin</a> attribute. The width and height must also be at least as large as the sizes specified by the <a href="https://www.graphviz.org/doc/info/attrs.html#d:width" target="_blank" rel="noopener">width</a> and <a href="https://www.graphviz.org/doc/info/attrs.html#d:height" target="_blank" rel="noopener">height</a> attributes, which specify the minimum values for these parameters. See the <a href="https://www.graphviz.org/doc/info/attrs.html#d:fixedsize" target="_blank" rel="noopener">fixedsize</a> attribute for ways of restricting the node size. In particular, if fixedsize=shape, the node’s shape will be fixed by the <a href="https://www.graphviz.org/doc/info/attrs.html#d:width" target="_blank" rel="noopener">width</a> and <a href="https://www.graphviz.org/doc/info/attrs.html#d:height" target="_blank" rel="noopener">height</a> attributes, and the shape is used for edge termination, but both the shape and label sizes are used preventing node overlap. For example, the following graph </p><p>有向图<code>G { {node [margin = 0 fontcolor = blue fontsize = 32 width = 0.5 shape = circle style = filled] b [fillcolor = yellow fixedsize = true label =“a very long label”] d [fixedsize = shape label =“更长的标签“]} a  - &gt; {cd} b  - &gt; {cd} }</code></p><p>digraph G { { node [margin=0 fontcolor=blue fontsize=32 width=0.5 shape=circle style=filled] b [fillcolor=yellow fixedsize=true label=”a very long label”] d [fixedsize=shape label=”an even longer label”] } a -&gt; {c d} b -&gt; {c d} } yields the figure<br><img src="https://www.graphviz.org/doc/info/fixed.gif" alt></p><p>得出这个图</p><p>Note that the label of the yellow node, with fixedsize=true, overlaps the other node, where there is sufficient space for the gray node with fixedsize=shape. </p><p>The shapes: note, tab, folder, box3d and component were provided by Pander. The synthetic biology shapes: promoter, cds, terminator, utr, primersite, restrictionsite, fivepoverhang, threepoverhang, noverhang, assembly, signature, insulator, ribosite, rnastab, proteasesite, proteinstab, rpromoter, rarrow, larrow and lpromoter were contributed by Jenny Cheng. </p><h2 id="Record-based-Nodes"><a href="#Record-based-Nodes" class="headerlink" title="Record-based Nodes"></a>Record-based Nodes</h2><p><strong>NOTE:</strong> Please see the note about record-based nodes at the <a href="#top">top</a> of this page. Also note that there are problems using non-trivial edges (edges with ports or labels) between adjacent nodes on the same rank if one or both nodes has a record shape. </p><p>These are specified by shape values of “record” and “Mrecord”. The structure of a record-based node is determined by its <a href="https://www.graphviz.org/doc/info/attrs.html#d:label" target="_blank" rel="noopener">label</a>, which has the following schema: </p><p><em>rlabel</em>=<em>field</em> ( ‘|’ <em>field</em> )* where <em>field</em>=fieldId or ‘{‘ <em>rlabel</em> ‘}’ and <em>fieldId</em>= [ ‘&lt;’ <em>string</em> ‘&gt;’] [ <em>string</em> ] </p><p>Braces, vertical bars and angle brackets must be escaped with a backslash character if you wish them to appear as a literal character. Spaces are interpreted as separators between tokens, so they must be escaped if you want spaces in the text. </p><p>The first string in <em>fieldId</em> assigns a portname to the field and can be combined with the node name to indicate where to attach an edge to the node. (See <a href="https://www.graphviz.org/doc/info/attrs.html#k:portPos" target="_blank" rel="noopener">portPos</a>.) The second string is used as the text for the field; it supports the usual <a href="https://www.graphviz.org/doc/info/attrs.html#k:escString" target="_blank" rel="noopener">escape sequences</a> \n, \l and \r. </p><p>Visually, a record is a box, with fields represented by alternating rows of horizontal or vertical subboxes. The Mrecord shape is identical to a record shape, except that the outermost box has rounded corners. Flipping between horizontal and vertical layouts is done by nesting fields in braces “{…}”. The top-level orientation in a record is horizontal. Thus, a record with label “A | B | C | D” will have 4 fields oriented left to right, while “{A | B | C | D}” will have them from top to bottom and “A | { B | C } | D” will have “B” over “C”, with “A” to the left and “D” to the right of “B” and “C”. </p><p>The initial orientation of a record node depends on the <a href="https://www.graphviz.org/doc/info/attrs.html#d:rankdir" target="_blank" rel="noopener">rankdir</a> attribute. If this attribute is TB (the default) or BT, corresponding to vertical layouts, the top-level fields in a record are displayed horizontally. If, however, this attribute is LR or RL, corresponding to horizontal layouts, the top-level fields are displayed vertically. </p><p>As an example of a record node, the dot input </p><p>digraph structs { node [shape=record]; struct1 [label=” left| mid\ dle| right”]; struct2 [label=” one| two”]; struct3 [label=”hello\nworld |{ b |{c| d|e}| f}| g | h”]; struct1:f1 -&gt; struct2:f0; struct1:f2 -&gt; struct3:here; } yields the figure<br><img src="https://www.graphviz.org/doc/info/record.gif" alt></p><p>If we add the line </p><p>rankdir=LR we get the layout<br><img src="https://www.graphviz.org/doc/info/record2.gif" alt></p><p>If we change node struct1 to have shape Mrecord, it then looks like:<br><img src="https://www.graphviz.org/doc/info/mrecord.gif" alt></p><h2 id="Styles-for-Nodes"><a href="#Styles-for-Nodes" class="headerlink" title="Styles for Nodes"></a>Styles for Nodes</h2><p>The <a href="https://www.graphviz.org/doc/info/attrs.html#d:style" target="_blank" rel="noopener">style</a> attribute can be used to modify the appearance of a node. At present, there are 8 style values recognized: filled, invisible, diagonals, rounded. dashed, dotted, solid and bold. As usual, the value of the <a href="https://www.graphviz.org/doc/info/attrs.html#d:style" target="_blank" rel="noopener">style</a> attribute can be a comma-separated list of any of these. If the style contains conflicts (e.g, style=”dotted, solid”), the last attribute wins. </p><ul><li>filled<br>This value indicates that the node’s interior should be filled. The color used is the node’s fillcolor or, if that’s not defined, its color. For unfilled nodes, the interior of the node is transparent to whatever color is the current graph or cluster background color. Note that point shapes are always filled. </li></ul><p>Thus, the code </p><p>digraph G { rankdir=LR node [shape=box, color=blue] node1 [style=filled] node2 [style=filled, fillcolor=red] node0 -&gt; node1 -&gt; node2 } yields the figure<br><img src="https://www.graphviz.org/doc/info/fill.gif" alt></p><ul><li>invisible<br>Setting this style causes the node not to be displayed at all. Note that the node is still used in laying out the graph. - diagonals<br>The diagonals style causes small chords to be drawn near the vertices of the node’s polygon or, in case of circles and ellipses, two chords near the top and the bottom of the shape. The special node shapes <a href="#d:Msquare">Msquare</a>, <a href="#d:Mcircle">Mcircle</a>, and <a href="#d:Mdiamond">Mdiamond</a> are simply an ordinary square, circle and diamond with the diagonals style set. - rounded<br>The rounded style causes the polygonal corners to be smoothed. Note that this style also applies to record-based nodes. Indeed, the Mrecord shape is simply shorthand for setting this style. Also, prior to 26 April 2005, the rounded and filled styles were mutually exclusive. </li></ul><p>As an example of rounding, dot uses the graph </p><p>digraph R { rankdir=LR node [style=rounded] node1 [shape=box] node2 [fillcolor=yellow, style=”rounded,filled”, shape=diamond] node3 [shape=record, label=”{ a | b | c }”] node1 -&gt; node2 -&gt; node3 } to produce the figure<br><img src="https://www.graphviz.org/doc/info/round.gif" alt></p><ul><li>dashed<br>This style causes the node’s border to be drawn as a dashed line. - dotted<br>This style causes the node’s border to be drawn as a dotted line. - solid<br>This style causes the node’s border to be drawn as a solid line, which is the default. - bold<br>This style causes the node’s border to be drawn as a bold line. See also <a href="https://www.graphviz.org/doc/info/attrs.html#d:penwidth" target="_blank" rel="noopener">penwidth</a>.<br>Additional styles may be available with a specific code generator. </li></ul><h2 id="HTML-Like-Labels"><a href="#HTML-Like-Labels" class="headerlink" title="HTML-Like Labels"></a>HTML-Like Labels</h2><p><strong>NOTE:</strong><em>This feature is only available on versions of Graphviz that are newer than mid-November 2003. In particular, it is not part of release 1.10.</em><strong>NOTE:</strong><em>The font markups for bold, italic, underlining, subscript and superscript</em>(<b>, <i>, <u>, <sub> and <sup>) <em>are only available in versions after 14 October 2011, and the markup for strike-through (<s>) requires versions later than 15 September 2013. In addition, all of these markups are currently only available via the cairo and svg renderers. The horizontal and vertical rules</s></em>(<hr> and <vr>) <em>are only available in versions later than 8 July 2011.</em></vr></sup></sub></u></i></b></p><p><strong>NOTE:</strong>_For releases later than 9 September 2014, one can use_shape=plain_so that the size of the node is totally determined by the label. Otherwise, the node’s margin, width and height values may cause the node to be larger, so that edges are clipped away from the label. In effect,_shape=plain_is shorthand for_shape=none width=0 height=0 margin=0. </p><p>If the value of a label attribute (<a href="https://www.graphviz.org/doc/info/attrs.html#d:label" target="_blank" rel="noopener">label</a> for nodes, edges, clusters, and graphs, and the <a href="https://www.graphviz.org/doc/info/attrs.html#d:headlabel" target="_blank" rel="noopener">headlabel</a> and <a href="https://www.graphviz.org/doc/info/attrs.html#d:taillabel" target="_blank" rel="noopener">taillabel</a> attributes of an edge) is given as an <a href="https://www.graphviz.org/doc/info/lang.html#html" target="_blank" rel="noopener">HTML string</a>, that is, delimited by &lt;…&gt; rather than “…”, the label is interpreted as an HTML description. At their simplest, such labels can describe multiple lines of variously aligned text as provided by ordinary <a href="https://www.graphviz.org/doc/info/attrs.html#k:escString" target="_blank" rel="noopener">string labels</a>. More generally, the label can specify a table similar to those provided by HTML, with different graphical attributes at each level. </p><p>As <a href="https://www.graphviz.org/doc/info/lang.html#html" target="_blank" rel="noopener">HTML strings</a> are processed like HTML input, any use of the “, &amp;, &lt;, and &gt; characters in literal text or in attribute values need to be replaced by the corresponding escape sequence. For example, if you want to use &amp; in an href value, this should be represented as &amp;. </p><p><strong>NOTE:</strong> The features and syntax supported by these labels are modeled on HTML. However, there are many aspects that are relevant to Graphviz labels that are not in HTML and, conversely, HTML allows various constructs which are meaningless in Graphviz. We will generally refer to these labels as “HTML labels” rather than the cumbersome “HTML-like labels” but the reader is warned that these are not really HTML. The grammar below describes precisely what Graphviz will accept. </p><p>Although HTML labels are not, strictly speaking, a shape, they can be viewed as a generalization of the record shapes described above. In particular, if a node has set its <a href="https://www.graphviz.org/doc/info/attrs.html#k:shape" target="_blank" rel="noopener">shape</a> attribute to none or plaintext, the HTML label will be the node’s shape. On the other hand, if the node has any other shape (except point), the HTML label will be embedded within the node the same way an ordinary label would be. </p><p>The following is an abstract grammar for HTML labels. Terminals, corresponding to elements, are shown in bold font, and nonterminals in italics. Square brackets [ and ] enclose optional items. Vertical bars | separate alternatives. Note that, as in HTML, element and attribute names are case-insensitive. (cf. sections 3.2.1 and 3.2.2 of the <a href="http://www.w3.org/TR/html401" target="_blank" rel="noopener">HTML 4.01 specification</a>). </p><p><em>label</em> : <em>text</em> | <em>fonttable__text</em> : <em>textitem</em> | <em>text__textitem__textitem</em> : <em>string</em> | <strong><br></strong> | <strong><font></font></strong><em>text</em><strong></strong> | <strong><i></i></strong><em>text</em><strong></strong> | <strong><b></b></strong><em>text</em><strong></strong> | <strong><u></u></strong><em>text</em><strong></strong> | <strong><o></o></strong><em>text</em><strong></strong> | <strong><sub></sub></strong><em>text</em><strong></strong> | <strong><sup></sup></strong><em>text</em><strong></strong> | <strong><s></s></strong><em>text</em><strong></strong><em>fonttable</em> : <em>table</em> | <strong><font></font></strong><em>table</em><strong></strong> | <strong><i></i></strong><em>table</em><strong></strong> | <strong><b></b></strong><em>table</em><strong></strong> | <strong><u></u></strong><em>table</em><strong></strong> | <strong><o></o></strong><em>table</em><strong></strong><em>table</em> : <strong><table></table></strong><em>rows</em><strong></strong><em>rows</em> : <em>row</em> | <em>rows__row</em> | <em>rows</em><strong><hr></strong><em>row__row</em> : <strong><tr></tr></strong><em>cells</em><strong></strong><em>cells</em> : <em>cell</em> | <em>cells__cell</em> | <em>cells</em><strong><vr></vr></strong><em>cell__cell</em> : <strong><td></td></strong><em>label</em><strong></strong> | <strong><td>**</td></strong><img><strong>**</strong></p><p>All non-printing characters such as tabs or newlines are ignored. Above, a <em>string</em> is any collection of printable characters, including spaces. For tables, outside of the body of a <td> element, whitespace characters are ignored, including spaces; within a </td><td> element, spaces are preserved but all other white space characters are discarded. <strong>N.B.</strong> For technical reasons, if a table is wrapped in a font element such as <font> or <b>, any space immediately before or after this will cause a syntax error. For example, the label </b></font></td></p><pre><code>&lt; &lt;U&gt;&lt;TABLE&gt;&lt;TR&gt;&lt;TD&gt;a&lt;/TD&gt;&lt;/TR&gt;&lt;/U&gt;&gt;</code></pre><p>is not legal. Removing either the space or the <u>…</u> will fix this. </p><p>HTML comments are allowed within an HTML string. They can occur anywhere provided that, if they contain part of an HTML element, they must contain the entire element. </p><p>As is obvious from the above description, the interpretation of white space characters is one place where HTML-like labels is very different from standard HTML. In HTML, any sequence of white space characters is collapsed to a single space, If the user does not want this to happen, the input must use non-breaking spaces “ “. This makes sense in HTML, where text layout depends dynamically on the space available. In Graphviz, the layout is statically determined by the input, so it is reasonable to treat ordinary space characters as non-breaking. In addition, ignoring tabs and newlines allows the input text to be formatted for easier reading. </p><p>Each of the HTML elements has a set of optional attributes. Attribute values must appear in double quotes. </p><!-- Table element --> <pre><code>&lt;TABLE  ALIGN=&quot;CENTER|LEFT|RIGHT&quot;  BGCOLOR=&quot;_color_&quot;  BORDER=&quot;_value_&quot;  CELLBORDER=&quot;_value_&quot;  CELLPADDING=&quot;_value_&quot;  CELLSPACING=&quot;_value_&quot;  COLOR=&quot;_color_&quot;  COLUMNS=&quot;_value_&quot;  FIXEDSIZE=&quot;FALSE|TRUE&quot;  GRADIENTANGLE=&quot;_value_&quot;  HEIGHT=&quot;_value_&quot;  HREF=&quot;_value_&quot;  ID=&quot;_value_&quot;  PORT=&quot;_portName_&quot;  ROWS=&quot;_value_&quot;  SIDES=&quot;_value_&quot;  STYLE=&quot;_value_&quot;  TARGET=&quot;_value_&quot;  TITLE=&quot;_value_&quot;  TOOLTIP=&quot;_value_&quot;  VALIGN=&quot;MIDDLE|BOTTOM|TOP&quot;  WIDTH=&quot;_value_&quot;&gt;</code></pre><!-- Table row --> <pre><code>&lt;TR  &lt;!-- No attributes --&gt;&gt;</code></pre><!-- Table cell --> <pre><code>&lt;TD  ALIGN=&quot;CENTER|LEFT|RIGHT|TEXT&quot;  BALIGN=&quot;CENTER|LEFT|RIGHT&quot;  BGCOLOR=&quot;_color_&quot;  BORDER=&quot;_value_&quot;  CELLPADDING=&quot;_value_&quot;  CELLSPACING=&quot;_value_&quot;  COLOR=&quot;_color_&quot;  COLSPAN=&quot;_value_&quot;  FIXEDSIZE=&quot;FALSE|TRUE&quot;  GRADIENTANGLE=&quot;_value_&quot;  HEIGHT=&quot;_value_&quot;  HREF=&quot;_value_&quot;  ID=&quot;_value_&quot;  PORT=&quot;_portName_&quot;  ROWSPAN=&quot;_value_&quot;  SIDES=&quot;_value_&quot;  STYLE=&quot;_value_&quot;  TARGET=&quot;_value_&quot;  TITLE=&quot;_value_&quot;  TOOLTIP=&quot;_value_&quot;  VALIGN=&quot;MIDDLE|BOTTOM|TOP&quot;  WIDTH=&quot;_value_&quot;&gt;</code></pre><!-- Font specification --> <pre><code>&lt;FONT  COLOR=&quot;_color_&quot;  FACE=&quot;_fontname_&quot;  POINT-SIZE=&quot;_value_&quot;&gt;</code></pre><!-- Line break --> <pre><code>&lt;BR  ALIGN=&quot;CENTER|LEFT|RIGHT&quot;/&gt;</code></pre><!-- Image inclusion --> <pre><code>&lt;IMG  SCALE=&quot;FALSE|TRUE|WIDTH|HEIGHT|BOTH&quot;  SRC=&quot;_value_&quot;/&gt;</code></pre><!-- Italic style --> <pre><code>&lt;I  &lt;!-- No attributes --&gt;&gt;</code></pre><!-- Bold style --> <pre><code>&lt;B  &lt;!-- No attributes --&gt;&gt;</code></pre><!-- Underline text --> <pre><code>&lt;U  &lt;!-- No attributes --&gt;&gt;</code></pre><!-- Overline text --> <pre><code>&lt;O  &lt;!-- No attributes --&gt;&gt;</code></pre><!-- Subscript text --> <pre><code>&lt;SUB  &lt;!-- No attributes --&gt;&gt;</code></pre><!-- Superscript text --> <pre><code>&lt;SUP  &lt;!-- No attributes --&gt;&gt;</code></pre><!-- Strike-through text --> <pre><code>&lt;S  &lt;!-- No attributes --&gt;&gt;</code></pre><!-- Horizontal rule --> <pre><code>&lt;HR  &lt;!-- No attributes --&gt;/&gt;</code></pre><!-- Vertical rule --> <pre><code>&lt;VR  &lt;!-- No attributes --&gt;/&gt;</code></pre><p><strong><em>ALIGN</em></strong></p><blockquote><p>specifies horizontal placement. When an object is allocated more space than required, this value determines where the extra space is placed left and right of the object. </p></blockquote><ul><li><blockquote><p>CENTER aligns the object in the center. (Default)</p></blockquote></li><li><blockquote><p>LEFT aligns the object on the left.</p></blockquote></li><li><blockquote><p>RIGHT aligns the object on the right.</p></blockquote></li><li><blockquote><p>(&gt; <td>&gt;  only) TEXT aligns lines of text using the full cell width. The alignment of a line is determined by its (possibly implicit) associated &gt; <br>&gt;  element.</td></p></blockquote></li></ul><blockquote><p>The contents of a cell are normally aligned as a block. In particular, lines of text are first aligned as a text block based on the width of the widest line and the corresponding &gt; <br>&gt;  elements. Then, the entire text block is aligned within a cell. If, however, the cell’s <strong><em>&gt; ALIGN</em></strong>&gt;  value is &gt; “TEXT”&gt; , and the cell contains lines of text, then the lines are justified using the entire available width of the cell. If the cell does not contain text, then the contained image or table is centered. </p></blockquote><p><strong><em>BALIGN</em></strong>&gt;  specifies the default alignment of &gt; <br>&gt;  elements contained in the cell. That is, if a &gt; <br>&gt;  element has no explicit <strong><em>&gt; ALIGN</em></strong>&gt;  attribute, the attribute value is specified by the value of <strong><em>&gt; BALIGN</em></strong>&gt; . <strong><em>BGCOLOR=”color”</em></strong>&gt;  sets the color of the background. This color can be overridden by a <strong><em>&gt; BGCOLOR</em></strong>&gt;  attribute in descendents. The value can be a single color or two colors separated by a colon, the latter indicating a gradient fill. <strong><em>BORDER=”value”</em></strong>&gt;  specifies the width of the border around the object in points. A value of zero indicates no border. The default is 1. The maximum value is 255. If set in a table, and <strong><em>&gt; CELLBORDER</em></strong>&gt;  is not set, this value is also used for all cells in the table. It can be overridden by a <strong><em>&gt; BORDER</em></strong>&gt;  tag in a cell. <strong><em>CELLBORDER=”value”</em></strong>&gt;  specifies the width of the border for all cells in a table. It can be overridden by a <strong><em>&gt; BORDER</em></strong>&gt;  tag in a cell. The maximum value is 255. <strong><em>CELLPADDING=”value”</em></strong>&gt;  specifies the space, in points, between a cell’s border and its content. The default is 2. The maximum value is 255. <strong><em>CELLSPACING=”value”</em></strong>&gt;  specifies the space, in points, between cells in a table and between a cell and the table’s border. The default is 2. The maximum value is 127. <strong><em>COLOR=”color”</em></strong>&gt;  sets the color of the font within the scope of <font>…</font>, or the border color of the table or cell within the scope of <table>…</table>, or <td>…</td>. This color can be overridden by a <strong><em>&gt; COLOR</em></strong>&gt;  attribute in descendents. By default, the font color is determined by the <a href="https://www.graphviz.org/doc/info/attrs.html#d:fontcolor" target="_blank" rel="noopener">&gt; fontcolor</a>&gt;  attribute of the corresponding node, edge or graph, and the border color is determined by the <a href="https://www.graphviz.org/doc/info/attrs.html#d:color" target="_blank" rel="noopener">&gt; color</a>&gt;  attribute of the corresponding node, edge or graph. <strong><em>COLSPAN=”value”</em></strong>&gt;  specifies the number of columns spanned by the cell. The default is 1. The maximum value is 65535. <strong><em>COLUMNS=”value”</em></strong>&gt;  provides general formatting information concerning the columns. At present, the only legal value is “*”, which causes a vertical rule to appear between every cell in every row. <strong><em>FACE=”fontname”</em></strong>&gt;  specifies the font to use within the scope of <font>…</font>. This can be overridden by a <strong><em>&gt; FACE</em></strong>&gt;  attribute in descendents. By default, the font name is determined by the <a href="https://www.graphviz.org/doc/info/attrs.html#d:fontname" target="_blank" rel="noopener">&gt; fontname</a>&gt;  attribute of the corresponding node, edge or graph. <strong><em>FIXEDSIZE</em></strong>&gt;  specifies whether the values given by the <strong><em>&gt; WIDTH</em></strong>&gt;  and <strong><em>&gt; HEIGHT</em></strong>&gt;  attributes are enforced. </p><ul><li><blockquote><p>FALSE allows the object to grow so that all its contents will fit. (Default)</p></blockquote></li><li><blockquote><p>TRUE fixes the object size to its given <strong><em>&gt; WIDTH</em></strong>&gt;  and <strong><em>&gt; HEIGHT</em></strong>&gt; . Both of these attributes must be supplied.</p></blockquote></li></ul><p><strong><em>GRADIENTANGLE=”value”</em></strong>&gt;  gives the angle used in a gradient fill if the <strong><em>&gt; BGCOLOR</em></strong>&gt;  is a color list. For the default linear gradient, this specifies the angle of a line through the center along which the colors transform. Thus, an angle of 0 will cause a left-to-right progression. For radial gradients (see <strong><em>&gt; STYLE</em></strong>&gt; ), the angle specifies the position of the center of the coloring. An angle of 0 places the center at the center of the table or cell; an non-zero angle places the fill center along that angle near the boundary. <strong><em>HEIGHT=”value”</em></strong>&gt;  specifies the mininum height, in points, of the object. The height includes the contents, any spacing and the border. Unless <strong><em>&gt; FIXEDSIZE</em></strong>&gt;  is true, the height will be expanded to allow the contents to fit. The maximum value is 65535. <strong><em>HREF=”value”</em></strong>&gt;  attaches a URL to the object. Note that the &gt; “value”&gt;  is treated as an <a href="https://www.graphviz.org/doc/info/attrs.html#k:escString" target="_blank" rel="noopener">&gt; escString</a>&gt;  similarly to the <a href="https://www.graphviz.org/doc/info/attrs.html#d:URL" target="_blank" rel="noopener">&gt; URL</a>&gt;  attribute. <strong><em>ID=”value”</em></strong>&gt;  allows the user to specify a unique ID for a table or cell. See the <a href="https://www.graphviz.org/doc/info/attrs.html#d:id" target="_blank" rel="noopener">&gt; id</a>&gt;  attribute for more information. Note that the &gt; “value”&gt;  is treated as an <a href="https://www.graphviz.org/doc/info/attrs.html#k:escString" target="_blank" rel="noopener">&gt; escString</a>&gt;  similarly to the <a href="https://www.graphviz.org/doc/info/attrs.html#d:id" target="_blank" rel="noopener">&gt; id</a>&gt;  attribute. <strong><em>POINT-SIZE=”value”</em></strong>&gt;  sets the size of the font, in points, used within the scope of <font>…</font>. This can be overridden by a <strong><em>&gt; POINT-SIZE</em></strong>&gt;  attribute in descendents. By default, the font size is determined by the <a href="https://www.graphviz.org/doc/info/attrs.html#d:fontsize" target="_blank" rel="noopener">&gt; fontsize</a>&gt;  attribute of the corresponding node, edge or graph. <strong><em>PORT=”value”</em></strong>&gt;  attaches a portname to the object. (See <a href="https://www.graphviz.org/doc/info/attrs.html#k:portPos" target="_blank" rel="noopener">&gt; portPos</a>&gt; .) This can be used to modify the head or tail of an edge, so that the end attaches directly to the object. <strong><em>ROWS=”value”</em></strong>&gt;  provides general formatting information concerning the rows. At present, the only legal value is “*”, which causes a horizontal rule to appear between every row. <strong><em>ROWSPAN=”value”</em></strong>&gt;  specifies the number of rows spanned by the cell. The default is 1. The maximum value is 65535. <strong><em>SCALE</em></strong>&gt;  specifies how an image will use any extra space available in its cell. Allowed values are </p><ul><li><blockquote><p>FALSE : keep image its natural size. (Default)</p></blockquote></li><li><blockquote><p>TRUE : scale image uniformly to fit.</p></blockquote></li><li><blockquote><p>WIDTH : expand image width to fill</p></blockquote></li><li><blockquote><p>HEIGHT : expand image height to fill</p></blockquote></li><li><blockquote><p>BOTH : expand both image width height to fill</p></blockquote></li></ul><blockquote><p>If this attribute is undefined, the image inherits the <a href="https://www.graphviz.org/doc/info/attrs.html#d:imagescale" target="_blank" rel="noopener">&gt; imagescale</a>&gt;  attribute of the graph object being drawn. As with the <a href="https://www.graphviz.org/doc/info/attrs.html#d:imagescale" target="_blank" rel="noopener">&gt; imagescale</a>&gt;  attribute, if the cell has a fixed size and the image is too large, any offending dimension will be shrunk to fit the space, the scaling being uniform in width and height if <em>&gt; SCALE=&gt; “true”</em>&gt; . Note that the containing cell’s <strong><em>&gt; ALIGN</em></strong>&gt;  and <strong><em>&gt; VALIGN</em></strong>&gt;  attributes override an image’s <strong><em>&gt; SCALE</em></strong>&gt;  attribute. <strong><em>SIDES=”value”</em></strong>&gt;  specifies which sides of a border in a cell or table should be drawn, if a border is drawn. By default, all sides are drawn. The &gt; “value”&gt;  string can contain any collection of the (case-insensitive) characters &gt; ‘L’&gt; , &gt; ‘T’&gt; , &gt; ‘R’&gt; , or &gt; ‘B’&gt; , corresponding to the left, top, right and, bottom sides of the border, respectively. For example, &gt; SIDES=”LB”&gt;  would indicate only the left and bottom segments of the border should be drawn. <strong><em>SRC=”value”</em></strong>&gt;  specifies the image file to be displayed in the cell. Note that if the software is used as a web server, file system access to images is more restricted. See <a href="https://www.graphviz.org/doc/info/command.html#d:GV_FILE_PATH" target="_blank" rel="noopener">&gt; GV_FILE_PATH</a>&gt;  and <a href="https://www.graphviz.org/doc/info/command.html#d:SERVER_NAME" target="_blank" rel="noopener">&gt; SERVER_NAME</a>&gt; . <strong><em>STYLE</em></strong></p></blockquote><blockquote><p>specifies style characteristics of the table or cell. Style characteristics are given as a comma or space separated list of style attributes. At present, the only legal attributes are “ROUNDED” and “RADIAL” for tables, and “RADIAL” for cells. If “ROUNDED” is specified, the table will have rounded corners. This probably works best if the outmost cells have no borders, or their CELLSPACING is sufficiently large. If it is desirable to have borders around the cells, use <em><strong>&gt; HR</strong></em>&gt;  and <em><strong>&gt; VR</strong></em>&gt;  elements, or the <em><strong>&gt; COLUMNS</strong></em>&gt;  and <em><strong>&gt; ROWS</strong></em>&gt;  attributes of <em><strong>&gt; TABLE</strong></em>&gt; . </p></blockquote><blockquote><p>The “RADIAL” attribute indicates a radial gradient fill. See the <strong><em>&gt; BGCOLOR</em></strong>&gt;  and <strong><em>&gt; GRADIENTANGLE</em></strong>&gt;  attributes. </p></blockquote><p><strong><em>TARGET=”value”</em></strong>&gt;  determines which window of the browser is used for the URL if the object has one. See <a href="http://www.w3.org/TR/html401/present/frames.html#adef-target" target="_blank" rel="noopener">&gt; W3C documentation</a>&gt; . Note that the &gt; “value”&gt;  is treated as an <a href="https://www.graphviz.org/doc/info/attrs.html#k:escString" target="_blank" rel="noopener">&gt; escString</a>&gt;  similarly to the <a href="https://www.graphviz.org/doc/info/attrs.html#d:target" target="_blank" rel="noopener">&gt; target</a>&gt;  attribute. <strong><em>TITLE=”value”</em></strong>&gt;  sets the tooltip annotation attached to the element. This is used only if the element has a HREF attribute. Note that the &gt; “value”&gt;  is treated as an <a href="https://www.graphviz.org/doc/info/attrs.html#k:escString" target="_blank" rel="noopener">&gt; escString</a>&gt;  similarly to the <a href="https://www.graphviz.org/doc/info/attrs.html#d:tooltip" target="_blank" rel="noopener">&gt; tooltip</a>&gt;  attribute. <strong><em>TOOLTIP=”value”</em></strong>&gt;  is an alias for <strong><em>&gt; TITLE</em></strong>&gt; . <strong><em>VALIGN</em></strong></p><blockquote><p>specifies vertical placement. When an object is allocated more space than required, this value determines where the extra space is placed above and below the object. </p></blockquote><ul><li><blockquote><p>MIDDLE aligns the object in the center. (Default)</p></blockquote></li><li><blockquote><p>BOTTOM aligns the object on the bottom.</p></blockquote></li><li><blockquote><p>TOP aligns the object on the top.</p></blockquote></li></ul><p><strong><em>WIDTH=”value”</em></strong>&gt;  specifies the mininum width, in points, of the object. The width includes the contents, any spacing and the border. Unless <strong><em>&gt; FIXEDSIZE</em></strong>&gt;  is true, the width will be expanded to allow the contents to fit. The maximum value is 65535. There is some inheritance among the attributes. If a table specifies a <em><strong>CELLPADDING</strong></em>, <em><strong>CELLBORDER</strong></em> or <em><strong>BORDER</strong></em> value, this value is used by the table’s cells unless overridden. If a cell or table specifies a <em><strong>BGCOLOR</strong></em>, this will be the background color for all of its descendents. Of course, if a background or fill color is specified for the graph object owning the label, this will be the original background for the label. The object’s fontname, fontcolor and fontsize attributes are the default for drawing text. These can be overridden by using <em><strong>FONT</strong></em> to set new values. The new font values will hold until overridden by an enclosed <em><strong>FONT</strong></em> element. Finally, the pencolor or color of the graph object will be used as the border color. </p><p>If you want horizontal or vertical rules used uniformly within a table, consider using the <em><strong>COLUMNS</strong></em> or <em><strong>ROWS</strong></em> attributes rather than using many <em><strong>HR</strong></em> and <em><strong>VR</strong></em> elements. </p><p>Because of certain limitations in handling tables in a device-independent manner, when <em><strong>BORDER</strong></em> is 1 and both table and cell borders are on and <em><strong>CELLSPACING</strong></em> is less than 2, anomalies can arise in the output, such as gaps between sides of borders which should be abutting or even collinear. The user can usual get around this by increasing the border size or the spacing, or turning off the table border. </p><p>As an example of HTML labels, the dot input </p><p>digraph structs { node [shape=plaintext] struct1 [label=&lt; </p><p>leftmid dleright </p><blockquote><p>]; struct2 [label=&lt; </p></blockquote><p>onetwo </p><blockquote><p>]; struct3 [label=&lt; </p></blockquote><p>hello<br>world b g h cde f </p><blockquote><p>]; struct1:f1 -&gt; struct2:f0; struct1:f2 -&gt; struct3:here; } produces the HTML analogue of the record example above<br><img src="https://www.graphviz.org/doc/info/html1.gif" alt></p></blockquote><p>As usual, an HTML specification is more verbose. On the other hand, HTML labels are much more general, as the following example shows: </p><p><img src="https://www.graphviz.org/doc/info/html2.gif" alt></p><p>The source for this graph can be found <a href="https://www.graphviz.org/doc/info/html2.gv" target="_blank" rel="noopener">here</a>. </p><p>Here is an example using <font> elements </font></p><p><img src="https://www.graphviz.org/doc/info/html3.gif" alt></p><p>with the <a href="https://www.graphviz.org/doc/info/html3.gv" target="_blank" rel="noopener">input graph</a>. </p><p>Here is an example using an <img> element </p><p><img src="https://www.graphviz.org/doc/info/html4.gif" alt></p><p>with the <a href="https://www.graphviz.org/doc/info/html4.gv" target="_blank" rel="noopener">input graph</a>. </p><p>The sides attribute (version 2.37 and later) allows one to combine cells to form various non-convex shapes. For example, a tee-shaped node </p><p><img src="https://www.graphviz.org/doc/info/tee.gif" alt></p><p>can be produced using </p><p>tee [shape=none margin=0 label= &lt;</p><blockquote><p>] ## User-defined Nodes</p></blockquote><p>There is a third type of node shape which is specified by the user. Typically, these shapes rely on the details of a concrete graphics format. At present, shapes can be described using PostScript, via a file or add-on library, for use in PostScript output, or shapes can be specified by a bitmap-image file for use with SVG or bitmap (jpeg, gif, etc.) output. More information can be found on the page <a href="https://www.graphviz.org/faq/#FaqCustShape" target="_blank" rel="noopener">How to create custom shapes</a>. </p><h2 id="SDL-Shapes-for-PostScript"><a href="#SDL-Shapes-for-PostScript" class="headerlink" title="SDL Shapes for PostScript"></a>SDL Shapes for PostScript</h2><p>One example of user-defined node shapes is provided by Mark Rison of CSR. These are the <a href="http://www.sdl-forum.org/SDL/index.htm" target="_blank" rel="noopener">SDL</a> shapes. These are available as PostScript functions whose use is described in <a href="https://www.graphviz.org/faq/#ext_ps_proc" target="_blank" rel="noopener">External PostScript procedures</a>. The necessary PostScript library file and sample use can be found in the contrib/sdlshapes directory in the release. Please note the COPYRIGHT AND PERMISSION NOTICE contained in the library file sdl.ps. </p><p>The table below gives the shape names and the corresponding node shapes. </p><p><img src="https://www.graphviz.org/doc/info/sdlshapes.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Node-Shapes-结点形状&quot;&gt;&lt;a href=&quot;#Node-Shapes-结点形状&quot; class=&quot;headerlink&quot; title=&quot;Node Shapes  结点形状&quot;&gt;&lt;/a&gt;Node Shapes  结点形状&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;There a
      
    
    </summary>
    
    
      <category term="graphviz dot" scheme="http://s.bixuebihui.cn/tags/graphviz-dot/"/>
    
  </entry>
  
  <entry>
    <title>Graphviz dot language spec</title>
    <link href="http://s.bixuebihui.cn/2019/09/07/Graphviz-dot-language-spec/"/>
    <id>http://s.bixuebihui.cn/2019/09/07/Graphviz-dot-language-spec/</id>
    <published>2019-09-07T10:23:41.000Z</published>
    <updated>2019-09-07T10:24:29.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DOT语言"><a href="#DOT语言" class="headerlink" title="DOT语言"></a>DOT语言</h1><p>以下是定义DOT语言的抽象语法。终端以粗体显示，非终端以斜体显示。文字字符以单引号给出。括号（和）表示需要时的分组。方括号[和]包含可选项。竖条| 单独的选择。</p><p><em>graph</em>    :    [ <strong>strict</strong> ] ( <strong>graph</strong> | <strong>digraph</strong> ) [ <em>ID</em> ] ‘{‘ stmt_list ‘}’<br>_ stmt_list _    :    [ stmt [ ‘;’ ] stmt_list ]<br><em>stmt</em>    :    node_stmt<br>|    edge_stmt<br>|    attr_stmt<br>|    <em>ID</em> ‘=’ <em>ID</em><br>|    subgraph<br><em>attr_stmt</em>    :    (<strong>graph</strong> | <strong>node</strong> | <strong>edge</strong>) attr_list<br><em>attr_list</em>    :    ‘[‘ [ a_list ] ‘]’ [ attr_list ]<br><em>a</em>list_    :    <em>ID</em> ‘=’ <em>ID</em> [ (‘;’ | ‘,’) ] [ a_list ]<br><em>edge_stmt</em>    :    (node_id | subgraph) <em>edgeRHS</em> [ attr_list ]<br><em>edgeRHS</em>    :    edgeop (node_id | subgraph) [ <em>edgeRHS</em> ]<br><em>node_stmt</em>    :    node_id [ attr_list ]<br><em>node_id</em>    :    <em>ID</em> [ port ]<br><em>port</em>    :    ‘:’ <em>ID</em> [ ‘:’ compass_pt ]<br>|    ‘:’ compass_pt<br><em>subgraph</em>    :    [ <strong>subgraph</strong> [ <em>ID</em> ] ] ‘{‘ stmt_list ‘}’<br><em>compass_pt</em>    :    (<strong>n</strong> | <strong>ne</strong> | <strong>e</strong> | <strong>se</strong> | <strong>s</strong> | <strong>sw</strong> | <strong>w</strong> | <strong>nw</strong> | <strong>c</strong> | <strong>_</strong> )</p><p>关键字node，edge，graph，digraph， subgraph和strict与大小写无关。另请注意，允许的罗盘点值不是关键字，因此这些字符串可以在别处用作普通标识符，相反，解析器实际上将接受任何标识符。</p><p><em>ID</em> 是下列之一：</p><ul><li>任何字母（[a-zA-Z\200-\377]）字符串，下划线（’_‘）或数字（[0-9]），不以数字开头;</li><li>数字 [-]?(.[0-9]+|[0-9]+(.[0-9]*)?);</li><li>任何双引号字符串 (“…”) 可能包含转义引号 (&quot;);</li><li>一个HTML字符串（&lt;…&gt;）。</li></ul><p>ID只是一个字符串; 前两种形式中缺少引号字符只是为了简单起见。<code>abc_2</code> 和<code>&quot;abc_2&quot;</code>之间或<code>2.34</code>和 <code>&quot;2.34&quot;</code>之间没有语义差异 。显然，要使用关键字作为 ID，必须引用它。请注意，在 HTML 字符串中，尖括号必须以匹配对的形式出现，并且允许使用换行符和其他格式的空白字符。此外，内容必须是合法的 XML，因此为了将这些字符嵌入属性值或原始文本中，可能需要 “，&amp;，&lt;和&gt;的特殊 XML 转义序列。作为 ID，HTML 字符串可以是任何合法的 XML 字符串。但是，如果用作标签属性，类似 HTML 的标签。<br>引用的字符串和 HTML 字符串都作为一个单元进行扫描，因此任何嵌入的注释都将被视为字符串的一部分。</p><p>一个 <em>edgeop</em> 在有向图中是 -&gt; 和在无向图中是 – 。</p><p>该语言支持 C++ 风格的注释：/*  */ 和//。 另外，以“#”字符开头的行被认为是来自C预处理器的行输出（例如，#34 以指示行34）并被丢弃。</p><p>分号和逗号有助于提高可读性，但不是必需的。此外，可以在结束符之间插入任何数量的空白。</p><p>作为可读性的另一个辅助点，dot 允许双引号字符串跨越多个物理行, 使用紧接在换行符之前的反斜杠的标准C约定来实现。此外，可以使用“+”运算符连接双引号字符串。由于 HTML 字符串可以包含仅用于格式化的换行符，因此该语言不允许在其中使用转义换行符或连接运算符。</p><h2 id="子图和集群"><a href="#子图和集群" class="headerlink" title="子图和集群"></a>子图和集群</h2><p>子图在Graphviz中扮演三个角色。首先，子图可用于表示图结构，表明某些节点和边应该组合在一起。这是子图的通常作用，通常指定有关图组件的语义信息。它还可以为边缘提供方便的简写。边缘语句允许边缘运算符的左侧和右侧都有子图。发生这种情况时，会从左侧的每个节点到右侧的每个节点创建一条边。例如，规范<br>    A  -&gt; {B C}<br>相当于<br>    A  -&gt; B<br>    A  -&gt; C</p><p>在第二个角色中，子图可以提供设置属性的上下文。例如，子图可以指定 blue 是其中定义的所有节点的默认颜色。在图形绘制的上下文中，一个更有趣的例子是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subgraph &#123; </span><br><span class="line">rank = same; A; B; C; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此（匿名）子图指定如果使用点绘制，节点A，B和C应全部放在相同的等级上。</p><p>子图的第三个角色直接涉及图形将如何由某些布局引擎布局。如果子图的名称以簇 cluster 开头，则 Graphviz 将子图注释为特殊的簇子图。如果支持，布局引擎将执行布局，以便将属于集群的节点绘制在一起，并将集群的整个绘图包含在边界矩形内。请注意，无论好坏，集群子图都不是 DOT 语言的一部分，而只是某些布局引擎所遵循的语法约定。</p><h2 id="词汇和语义笔记"><a href="#词汇和语义笔记" class="headerlink" title="词汇和语义笔记"></a>词汇和语义笔记</h2><p>必须将图形指定为有向图或图形。在语义上，这表示是否存在从边缘节点之一到另一个节点的自然方向。从词法上讲，有向图必须使用边运算符指定边 -&gt; 而无向图必须使用 – 。在操作上，该区别用于定义不同的默认呈现属性。例如，默认情况下，将使用指向头节点的箭头绘制有向图中的边。对于普通图形，默认情况下绘制的边没有任何箭头。</p><p>图表也可以描述为严格的 <strong>strict</strong> 。这禁止创建多边缘，即，在定向情况下，最多只有一个边具有给定的尾节点和头节点。对于无向图，最多可以有一个边连接到相同的两个节点。使用相同的两个节点的后续边缘语句将使用先前定义的边缘语句识别边缘, 并应用边缘语句中给出的任何属性。例如，图表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strict graph &#123; </span><br><span class="line">  a -- b</span><br><span class="line">  a -- b</span><br><span class="line">  b -- a [color=blue]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将有一个连接节点 a 和 b 的边，其颜色为蓝色。<br>如果使用节点， 边或图形语句或未附加到节点或边的属性赋值定义默认属性，则之后定义的任何相应类型的对象将继承此属性值。这将保持不变，直到将默认属性设置为新值，从该点开始使用新值。在设置默认属性之前定义的对象在创建默认属性定义后将具有附加到属性的空字符串值。</p><p>特别要注意，子图在定义时接收其父图的属性设置。这可能很有用; 例如，可以将字体分配给根图，所有子图也将使用该字体。但是，对于某些属性，此属性是不合需要的。如果将标签附加到根图上，则所有子图使用标签可能不是所希望的效果。不是在图形顶部列出图形属性，而是在子图形中根据需要重置属性，可以简单地推迟图形中的属性定义，直到定义了适当的子图形。</p><p>如果边缘属于群集，则其端点属于该群集。因此，放置边的位置可以影响布局，因为簇有时会递归布局。</p><p>子图和集群有一些限制。首先，目前，图形及其子图的名称共享相同的名称空间。因此，每个子图必须具有唯一的名称。其次，虽然节点可以属于任意数量的子图，但是当被视为节点和边的子集时，假设簇形成严格的层次结构。</p><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>DOT 语言至少假设 ascii 字符集。带引号的字符串，无论是普通字符串还是类 HTML 字符串，都可能包含非 ascii 字符。在大多数情况下，这些字符串是未被解释的：它们只是作为唯一标识符或通过未触及传递的值。但是，要显示标签，这要求软件能够计算文本的大小并确定适当的字形。为此，它需要知道使用什么字符编码。<br>默认情况下，DOT 采用 UTF-8 字符编码。它还接受 Latin1（ISO-8859-1）字符集，假设输入图使用 <a href="https://graphviz.gitlab.io/_pages/doc/info/attrs.html#a:charset" target="_blank" rel="noopener">charset</a> 属性来指定它。对于使用其他字符集的图形，通常有程序，例如 iconv，它将从一个字符集转换为另一个字符集。</p><p>避免标签中非 ascii 字符的另一种方法是将 HTML 实体用于特殊字符。在标签评估期间，这些实体被转换为基础角色。此 <a href="https://graphviz.gitlab.io/_pages/doc/char.html" target="_blank" rel="noopener">表</a> 显示受支持的实体及其 Unicode 值，典型字形和 HTML 实体名称。因此，要将小写的希腊语 beta 包含在字符串中，可以使用 ascii 序列和 <code>&amp;beta;</code>; 。通常，应该只使用输出字符集中允许的实体，并且字体中有一个字形。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DOT语言&quot;&gt;&lt;a href=&quot;#DOT语言&quot; class=&quot;headerlink&quot; title=&quot;DOT语言&quot;&gt;&lt;/a&gt;DOT语言&lt;/h1&gt;&lt;p&gt;以下是定义DOT语言的抽象语法。终端以粗体显示，非终端以斜体显示。文字字符以单引号给出。括号（和）表示需要时的分组。
      
    
    </summary>
    
    
      <category term="graphviz dot" scheme="http://s.bixuebihui.cn/tags/graphviz-dot/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop - Big Data Solutions</title>
    <link href="http://s.bixuebihui.cn/2019/09/07/Hadoop-Big-Data-Solutions/"/>
    <id>http://s.bixuebihui.cn/2019/09/07/Hadoop-Big-Data-Solutions/</id>
    <published>2019-09-07T03:12:32.000Z</published>
    <updated>2019-09-08T15:29:58.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hadoop-大数据解决方案"><a href="#Hadoop-大数据解决方案" class="headerlink" title="Hadoop - 大数据解决方案"></a>Hadoop - 大数据解决方案</h1><h1 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h1><p>在这种方法中，企业将拥有一台计算机来存储和处理大数据。出于存储目的，程序员将借助他们选择的数据库供应商（如Oracle，IBM等）。在这种方法中，用户与应用程序交互，而应用程序又处理数据存储和分析的部分。</p><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuKh9J2zABCXGA2bAJCaioSpFg-PwFcN5iuxj2hfs2azsh7swl_dvvjtFTyzNY5OepaWiIBLDogymJb68vKAH12f-shePo7awh_lPr0tFUjSztJKPhYMvCYSpBoMr2AYhbiiXDIy5Q3C0"><h1 id="大数据传统方法"><a href="#大数据传统方法" class="headerlink" title="大数据传统方法"></a>大数据传统方法</h1><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>这种方法适用于那些处理标准数据库服务器可以容纳的大量数据的应用程序，或者处理数据的处理器的限制。但是，当涉及处理大量可扩展数据时，通过单个数据库瓶颈处理此类数据是一项繁忙的任务。</p><p>谷歌的解决方案<br>Google使用名为MapReduce的算法解决了这个问题。该算法将任务分成小部分并将它们分配给许多计算机，并从中收集结果，这些结果在集成时形成结果数据集。</p><p>谷歌MapReduce<br>Hadoop的<br>使用谷歌提供的解决方案，Doug Cutting和他的团队开发了一个名为HADOOP的开源项目。</p><p>Hadoop使用MapReduce算法运行应用程序，其中数据与其他算法并行处理。简而言之，Hadoop用于开发可以对大量数据执行完整统计分析的应用程序。</p><p>Hadoop框架</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hadoop-大数据解决方案&quot;&gt;&lt;a href=&quot;#Hadoop-大数据解决方案&quot; class=&quot;headerlink&quot; title=&quot;Hadoop - 大数据解决方案&quot;&gt;&lt;/a&gt;Hadoop - 大数据解决方案&lt;/h1&gt;&lt;h1 id=&quot;传统方法&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="hadoop" scheme="http://s.bixuebihui.cn/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop - 大数据概述</title>
    <link href="http://s.bixuebihui.cn/2019/09/06/Hadoop-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0/"/>
    <id>http://s.bixuebihui.cn/2019/09/06/Hadoop-大数据概述/</id>
    <published>2019-09-06T14:51:30.000Z</published>
    <updated>2019-09-07T11:50:07.300Z</updated>
    
    <content type="html"><![CDATA[<p>“世界上90％的数据是在过去几年中产生的。”<br>由于社交网站等新技术，设备和通信方式的出现，人类每年产生的数据量正在迅速增长。之前全部到2003年为止，我们生成的数据量为5050亿GB。如果你以磁盘的形式堆积数据，它可能会填满整个足球场。2011年每两天创造相同的数量，2013年每十分钟创建这么多。这个比率仍在大幅增长。虽然所有这些信息都是有意义的，并且在处理时很有用，但它却被忽略了。</p><h1 id="什么是大数据？"><a href="#什么是大数据？" class="headerlink" title="什么是大数据？"></a>什么是大数据？</h1><p>大数据是无法使用传统计算技术处理的大型数据集的集合。它不是单一的技术或工具，而是已成为一个完整的主题，涉及各种工具，技术和框架。</p><h1 id="大数据从何而来？"><a href="#大数据从何而来？" class="headerlink" title="大数据从何而来？"></a>大数据从何而来？</h1><p>大数据涉及不同设备和应用程序生成的数据。以下是大数据旗下的一些领域。</p><ul><li><p>黑匣子数据 - 它是直升机，飞机和喷气式飞机等的一个组成部分。它捕获机组人员的声音，麦克风和耳机的录音以及飞机的性能信息。</p></li><li><p>社交媒体数据 - Facebook和Twitter等社交媒体可以保存全球数百万人发布的信息和观点。</p></li><li><p>证券交易所数据 - 证券交易所数据包含有关客户制作的不同公司股票的“买入”和“卖出”决策的信息。</p></li><li><p>电网数据 - 电网数据保存特定节点相对于基站消耗的信息。</p></li><li><p>运输数据 - 运输数据包括车辆的型号，容量，距离和可用性。</p></li><li><p>搜索引擎数据 - 搜索引擎从不同的数据库中检索大量数据。</p></li></ul><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><p>因此，大数据包括大量，高速和可扩展的各种数据。其中的数据有三种类型。</p><ul><li><p>结构化数据 - 关系数据。</p></li><li><p>半结构化数据 - XML数据。</p></li><li><p>非结构化数据 - Word，PDF，文本，媒体日志。</p></li></ul><h2 id="大数据的好处"><a href="#大数据的好处" class="headerlink" title="大数据的好处"></a>大数据的好处</h2><ul><li><p>使用Facebook等社交网络中保存的信息，营销机构从中了解其广告，促销活动和其他媒体的响应情况。</p></li><li><p>使用社交媒体中的信息，例如消费者的偏好和产品感知，产品公司和零售组织正在计划他们的生产。</p></li><li><p>使用有关患者既往病史的数据，医院正在提供更好，更快捷的服务。</p></li></ul><h2 id="大数据技术"><a href="#大数据技术" class="headerlink" title="大数据技术"></a>大数据技术</h2><p>大数据技术对于提供更准确的分析非常重要，这可能会导致更具体的决策，从而提高运营效率，降低成本并降低业务风险。</p><p>要利用大数据的强大功能，您需要一个能够实时管理和处理大量结构化和非结构化数据的基础架构，并可以保护数据隐私和安全。</p><p>市场上有来自不同供应商的各种技术，包括亚马逊，IBM，微软等，以处理大数据。在研究处理大数据的技术时，我们研究了以下两类技术 -</p><ul><li>运营大数据<br>这包括像MongoDB这样的系统，它们为主要捕获和存储数据的实时交互式工作负载提供操作功能。</li></ul><p>NoSQL大数据系统旨在利用过去十年中出现的新的云计算架构，以便以低成本和高效率运行大规模计算。这使得运营大数据工作负载更易于管理，更便宜，实施更快。</p><p>一些NoSQL系统可以基于实时数据提供对模式和趋势的洞察，只需最少的编码，无需数据科学家和其他基础设施。</p><ul><li>分析大数据<br>这些系统包括大规模并行处理（MPP）数据库系统和MapReduce等系统，这些系统为可能接触大部分或全部数据，为回顾性和复杂分析提供分析能力。</li></ul><p>MapReduce提供了一种分析数据的新方法，该方法与SQL提供的功能互补，并且基于MapReduce的系统可以从单个服务器扩展到数千台高端和低端机器。</p><p>这两类技术是互补的，并且经常一起部署。</p><h2 id="运营与分析系统"><a href="#运营与分析系统" class="headerlink" title="运营与分析系统"></a>运营与分析系统</h2><table><thead><tr><th></th><th align="right">运营系统</th><th align="right">分析系统</th></tr></thead><tbody><tr><td>延迟</td><td align="right">1毫秒 - 100毫秒</td><td align="right">1分钟 - 100分钟</td></tr><tr><td>并发</td><td align="right">1000 - 100,000</td><td align="right">1 - 10</td></tr><tr><td>访问模式</td><td align="right">写和读</td><td align="right">读</td></tr><tr><td>查询</td><td align="right">可选择的</td><td align="right">非选择性</td></tr><tr><td>数据范围</td><td align="right">运营部分</td><td align="right">可回顾的</td></tr><tr><td>最终用户</td><td align="right">顾客</td><td align="right">数据科学家</td></tr><tr><td>技术</td><td align="right">NoSQL</td><td align="right">MapReduce，MPP数据库</td></tr></tbody></table><h2 id="大数据挑战"><a href="#大数据挑战" class="headerlink" title="大数据挑战"></a>大数据挑战</h2><p>与大数据相关的主要挑战如下 -</p><ul><li>捕获数据</li><li>策展(训化？）</li><li>存储</li><li>搜索</li><li>分享</li><li>传输</li><li>分析</li><li>展示 </li></ul><p>为了应对上述挑战，各类组织通常会借助企业服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“世界上90％的数据是在过去几年中产生的。”&lt;br&gt;由于社交网站等新技术，设备和通信方式的出现，人类每年产生的数据量正在迅速增长。之前全部到2003年为止，我们生成的数据量为5050亿GB。如果你以磁盘的形式堆积数据，它可能会填满整个足球场。2011年每两天创造相同的数量，
      
    
    </summary>
    
    
      <category term="hadoop" scheme="http://s.bixuebihui.cn/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>help</title>
    <link href="http://s.bixuebihui.cn/2019/09/06/help/"/>
    <id>http://s.bixuebihui.cn/2019/09/06/help/</id>
    <published>2019-09-06T14:06:17.000Z</published>
    <updated>2019-09-06T14:06:17.472Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hadoop 入门</title>
    <link href="http://s.bixuebihui.cn/2019/09/06/Hadoop-%E5%85%A5%E9%97%A8/"/>
    <id>http://s.bixuebihui.cn/2019/09/06/Hadoop-入门/</id>
    <published>2019-09-06T14:05:55.000Z</published>
    <updated>2019-09-08T07:07:14.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hadoop教程"><a href="#Hadoop教程" class="headerlink" title="Hadoop教程"></a>Hadoop教程</h1><p>Hadoop是一个开源框架，允许使用简单的编程模型在分布式环境中跨计算机集群存储和处理大数据。它旨在从单个服务器扩展到数千台计算机，每台计算机都提供本地计算和存储。</p><p>本教程简要介绍了大数据，MapReduce算法和Hadoop分布式文件系统。</p><h2 id="听众"><a href="#听众" class="headerlink" title="听众"></a>听众</h2><p>本教程是为有志于使用Hadoop Framework学习大数据分析基础知识并成为Hadoop开发人员的专业人士准备的。软件专业人员，分析专业人员和ETL开发人员是本课程的主要受益者。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>在开始学习本教程之前，我们假设您事先已经了解过Core Java，数据库概念以及任何Linux操作系统风格。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hadoop教程&quot;&gt;&lt;a href=&quot;#Hadoop教程&quot; class=&quot;headerlink&quot; title=&quot;Hadoop教程&quot;&gt;&lt;/a&gt;Hadoop教程&lt;/h1&gt;&lt;p&gt;Hadoop是一个开源框架，允许使用简单的编程模型在分布式环境中跨计算机集群存储和处理大数据
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>plantuml test</title>
    <link href="http://s.bixuebihui.cn/2019/09/05/plantuml-test/"/>
    <id>http://s.bixuebihui.cn/2019/09/05/plantuml-test/</id>
    <published>2019-09-05T11:16:19.000Z</published>
    <updated>2019-09-05T11:20:38.577Z</updated>
    
    <content type="html"><![CDATA[<img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuNBAJrBGjLDmpCbCJbMmKiX8pSd9vt98pKi1IW80">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuNBAJrBGjLDmpCbCJbMmKiX8pSd9vt98pKi1IW80&quot;&gt;


      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>we have problem with promise</title>
    <link href="http://s.bixuebihui.cn/2019/08/27/we-have-problem-with-promise/"/>
    <id>http://s.bixuebihui.cn/2019/08/27/we-have-problem-with-promise/</id>
    <published>2019-08-27T13:07:30.000Z</published>
    <updated>2019-08-27T22:53:16.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-Promise-–-承诺之困惑"><a href="#JavaScript-Promise-–-承诺之困惑" class="headerlink" title="JavaScript Promise – 承诺之困惑"></a>JavaScript Promise – 承诺之困惑</h1><p>诺兰劳森<br>作者： Nolan Lawson<br>发布时间： 2015年5月18日</p><p>JavaScripters研究员，现在是时候承认了：我们对承诺有疑惑。</p><p>不，不是承诺自己。承诺，如<a href="https://promisesaplus.com/" target="_blank" rel="noopener">A+ 规范</a>所定义，非常棒。</p><p>这个问题在过去一年里向我展示了，因为我看到很多程序员都在尽可能使用 Promise 方式的API，但：</p><p>我们许多人都使用的Promise, 但并没有真正理解他们。</p><p>如果您觉得难以置信，请考虑我最近发布到<a href="https://twitter.com/nolanlawson/status/578948854411878400" target="_blank" rel="noopener">Twitter</a>的这个难题：</p><p><strong>问：这四项承诺有什么区别？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  doSomethingElse();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse());</span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse);</span><br></pre></td></tr></table></figure><p>如果你知道答案，那么恭喜你：你是一个承诺忍者。您可以停止阅读此博文了。</p><p>对于其他99.99％的人，你不孤单。没有人回复我的推文说可以解决它，我自己也对＃3的回答感到惊讶。是的，即便这个测验问题是我写的！</p><p>答案是在这篇文章的最后，首先，我想探讨为什么承诺是如此难缠，为什么我们这么多人 - 新手和专家 - 被他们绊倒了。我也将提供一个的视角，一个小伎俩，这我确信之后不再难理解！</p><p>但首先，让我们挑战一些关于承诺的常见假设。</p><h1 id="所以为啥承诺？"><a href="#所以为啥承诺？" class="headerlink" title="所以为啥承诺？"></a>所以为啥承诺？</h1><p>如果你阅读有关承诺的文献，你会经常找到对<a href="https://medium.com/@wavded/managing-node-js-callback-hell-1fe03ba8baf" target="_blank" rel="noopener">厄运金字塔</a>的引用，其中一些可怕的回调代码会稳定地向屏幕的右侧延伸。</p><p>Promise 确实解决了这个问题，但它不仅仅是缩进。正如精彩的演讲“<a href="http://youtu.be/hf1T_AONQJU" target="_blank" rel="noopener">来自回调地狱的救赎</a>”中所解释的那样，回调的真正问题是它们剥夺了关键字 return 和 throw。与之相反，程序的整个流程基于一种副作用：一个函数偶然调用另一个函数。</p><p>事实上，回调做了一些更加险恶的事情：它们剥夺了我们的堆栈，这是我们在编程语言中通常认为理所当然的事情。没有堆叠编写代码就像驾驶没有刹车踏板的汽车一样：你没有意识到没它有多么糟糕，直到你到了却发现它不在。</p><p>承诺的全部意义是给我们找回来，因异步失去的语言基础：return，throw，和堆栈。但是你必须知道如何正确使用 promise 才能利用它们。</p><h1 id="菜鸟的错误"><a href="#菜鸟的错误" class="headerlink" title="菜鸟的错误"></a>菜鸟的错误</h1><p>有些人试图将承诺解释为<a href="http://andyshora.com/promises-angularjs-explained-as-cartoon.html" target="_blank" rel="noopener">卡通</a>，或以名词为导向的方式：“哦，这是你可以传递的东西，它代表一个异步值。”</p><p>我没有发现这样的解释非常有帮助。对我来说，承诺都是关于代码结构和流程的。所以我认为最好只是回顾一些常见错误并展示如何修复它们。我称之为“菜鸟错误”的意思是，“你现在是个新手，孩子，但你很快就会成为职业选手。”</p><blockquote><p>快速离题：“承诺”对不同的人来说意味着很多不同的东西，但就本文而言，我只会谈论官方规范，在现代浏览器中暴露出来 window.Promise。不是所有浏览器都有 window.Promise，所以对于一个好的polyfill，请查看名为<a href="https://github.com/calvinmetcalf/lie" target="_blank" rel="noopener">Lie</a>的，这是关于最小的符合规范的库。</p></blockquote><h2 id="菜鸟错误＃1：厄运的有希望的金字塔"><a href="#菜鸟错误＃1：厄运的有希望的金字塔" class="headerlink" title="菜鸟错误＃1：厄运的有希望的金字塔"></a>菜鸟错误＃1：厄运的有希望的金字塔</h2><p>看看人们如何使用基于承诺的API，我看到很多糟糕的承诺模式。最常见的不良做法是这个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(&#123;</span><br><span class="line">  include_docs: <span class="literal">true</span>,</span><br><span class="line">  attachments: <span class="literal">true</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> docs = result.rows;</span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    localdb.put(element.doc).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">"Pulled doc with id "</span> + element.doc._id + <span class="string">" and added to local db."</span>);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err.name == <span class="string">'conflict'</span>) &#123;</span><br><span class="line">        localdb.get(element.doc._id).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line">          localdb.remove(resp._id, resp._rev).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line"><span class="comment">// et cetera...</span></span><br></pre></td></tr></table></figure><p>是的，事实证明你可以使用promise，好像它们是回调一样，是的，它就像使用电动打磨机来装饰指甲一样，是，你可以做到。</p><p>如果您认为这种错误仅限于绝对的初学者，您会惊讶地发现我实际上从官方的<a href="http://devblog.blackberry.com/2015/05/connecting-to-couchbase-with-pouchdb/" target="_blank" rel="noopener">BlackBerry开发者博客</a>中获取了上述代码！旧的回调习惯很难。（对开发者来说：抱歉选择你，但你的例子很有启发性。）</p><p>这是一个更好的风格：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(...).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfAllDocs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfPut</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.get(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfGet</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这被称为组合承诺，它是承诺的伟大之处。只有在前一个 promise 已经解决时才会调用下一个函数，并且将使用该 promise 的输出作为参数调用它。稍后会详细介绍。</p><h2 id="菜鸟错误＃2：WTF，我如何使用forEach-承诺？"><a href="#菜鸟错误＃2：WTF，我如何使用forEach-承诺？" class="headerlink" title="菜鸟错误＃2：WTF，我如何使用forEach()承诺？"></a>菜鸟错误＃2：WTF，我如何使用forEach()承诺？</h2><p>这是大多数人对承诺的理解开始崩溃的地方。一旦他们达到他们熟悉的forEach()循环（或for循环或while循环），他们就不知道如何使它与promises一起工作。所以他们写这样的东西：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// I want to remove() all docs</span></span><br><span class="line">db.allDocs(&#123;<span class="attr">include_docs</span>: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  result.rows.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>&#123;</span><br><span class="line">    db.remove(row.doc);  </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I naively believe all docs have been removed() now!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码有什么问题？问题是第一个函数实际上正在返回 undefined，这意味着第二个函数不能期待<code>db.remove()</code>在所有文档上调用。事实上，它并没有期待任何东西，并且可以在删除任意数量的文档时执行！</p><p>这是一个特别隐蔽的错误，因为您可能没有注意到任何错误，假设足够快地删除这些文档以便更新UI。该错误可能只会在奇怪的竞争条件下弹出，或者在某些浏览器中弹出，此时调试几乎是不可能的。</p><p>所有这些的 forEach()/for/while 不应是你要的结构。你想要的是 Promise.all()：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.allDocs(&#123;<span class="attr">include_docs</span>: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(result.rows.map(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> db.remove(row.doc);</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">arrayOfResults</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// All docs have really been removed() now!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里发生了什么？本质上 Promise.all() 将一系列承诺作为输入，然后它为您提供另一个承诺，只有当其他承诺中的每一个都已解决时才会解决。它是 for 循环的异步等价物。</p><p>Promise.all() 还会将一个结果数组传递给下一个函数，这可能会非常有用，例如，如果您尝试从 DB 中执行多项 get() 操作。如果 Promise.all() 拒绝了它的子承诺中的任何一个都将被拒绝，这是更加有用。</p><h2 id="菜鸟错误＃3：忘记添加-catch"><a href="#菜鸟错误＃3：忘记添加-catch" class="headerlink" title="菜鸟错误＃3：忘记添加.catch()"></a>菜鸟错误＃3：忘记添加<code>.catch()</code></h2><p>这是另一个常见的错误。幸福地相信他们的承诺永远不会抛出错误，许多开发人员忘记<code>.catch()</code>在他们的代码中添加任何地方。不幸的是，这意味着任何抛出的错误都会被吞下，你甚至都不会在控制台中看到它们。这可能是一个真正的调试痛苦。</p><p>为了避免这种令人讨厌的情况，我已经养成了将以下代码添加到我的承诺链中的习惯：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> anotherPromise();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> yetAnotherPromise();</span><br><span class="line">&#125;).catch(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)); <span class="comment">// &lt;-- this is badass</span></span><br></pre></td></tr></table></figure><p>即使您从未预料到会有错误，添加一个<code>catch()</code>也总是谨慎的。如果您的假设是错的，它会让您的生活更轻松。</p><h2 id="菜鸟错误＃4：使用“延迟”-deffered"><a href="#菜鸟错误＃4：使用“延迟”-deffered" class="headerlink" title="菜鸟错误＃4：使用“延迟” - deffered"></a>菜鸟错误＃4：使用“延迟” - deffered</h2><p>这是一个错误，我<a href="http://gonehybrid.com/how-to-use-pouchdb-sqlite-for-local-storage-in-your-ionic-app/" target="_blank" rel="noopener">总看到</a>，我不愿甚至在这里重复了，怕的是，像阴间大法师，只要提它的名字就将召唤它的多个实例。</p><p>简而言之，承诺有着漫长而传奇的历史，JavaScript 社区需要很长时间才能正确使用。在早期，jQuery 和 Angular 到处使用这种“延迟”模式，现在已经被 ES6 Promise 规范取代，由 Q，When，RSVP，Bluebird，Lie等“好”库实现。其他。</p><p>所以如果你在你的代码中写下这个词（我不会第三次重复它！），你做错了。这是如何避免它。</p><p>首先，大多数承诺库为您提供了一种从第三方库“导入”承诺的方法。例如，Angular的$q模块允许您使用包装非$q, 承诺$q.when()。所以Angular用户可以这样包装PouchDB承诺：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$q.when(db.put(doc)).then(<span class="comment">/* ... */</span>); <span class="comment">// &lt;-- this is all the code you need</span></span><br></pre></td></tr></table></figure><p>另一种策略是使用构造函数模式，这对于包装非承诺 API 非常有用。例如，要包装像 Node 这样的基于回调的 API，如 fs.readFile()，您可以简单地执行以下操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'myfile.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(file);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="comment">/* ... */</span>)</span><br></pre></td></tr></table></figure><p>完成！</p><blockquote><p>有关<em>为什么这是反模式</em>的更多信息，请查看有关承诺反模式的<a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern" target="_blank" rel="noopener">Bluebird wiki</a>页面。</p></blockquote><h2 id="菜鸟错误＃5：使用副作用而不是返回"><a href="#菜鸟错误＃5：使用副作用而不是返回" class="headerlink" title="菜鸟错误＃5：使用副作用而不是返回"></a>菜鸟错误＃5：使用副作用而不是返回</h2><p>这段代码出了什么问题？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  someOtherPromise();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Gee, I hope someOtherPromise() has resolved!</span></span><br><span class="line">  <span class="comment">// Spoiler alert: it hasn't.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>好的，这是谈谈你需要知道的有关承诺的一切的优点。</p><p>说真的，这是一个奇怪的的技巧，一旦你理解了它，就会阻止我一直在谈论的所有错误。你准备好了吗？</p><p>正如我之前所说，承诺神奇的是，他们给我们带回到我们的宝贵return和throw。但这在实践中实际上是什么样的？</p><p>每一个承诺都会给你一个then()方法（或者catch()，它只是语法糖then(null, …)）。这里我们是一个then()函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I'm inside a then() function!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里，我们在做什么？有三件事：</p><ul><li>return 另一个承诺</li><li>return 同步值（或undefined）</li><li>throw 同步错误</li></ul><p>如此而已。一旦你理解了这个技巧，你就会理解承诺。所以让我们一次一个地浏览每一个点。</p><p>1.返回另一个承诺<br>这是您在承诺文献中看到的常见模式，如上面的“撰写承诺”示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>请注意，我是return第二个承诺 - 这return是至关重要的。如果我没有说return，那么getUserAccountById()实际上只是起副作用，而下一个函数将接收undefined而不是userAccount。</p><p>2.返回同步值（或未定义）<br>返回 undefined 通常是一个错误，但返回同步值实际上是将同步代码转换为承诺代码的一种好方法。例如，假设我们有一个用户内存缓存。我们可以做的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id];    <span class="comment">// returning a synchronous value!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id); <span class="comment">// returning a promise!</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那不是很棒吗？第二个函数不关心userAccount是同步还是异步获取，第一个函数可以自由返回同步或异步值。</p><p>不幸的是，有一个不方便的事实，即 JavaScript 中的非返回函数在技术上会返回 undefined，这意味着当你想要返回某些内容时，很容易意外地引入副作用。</p><p>出于这个原因，我养成了一个个人习惯，总是从then()函数内部返回或抛出异常。我建议你也这样做。</p><p>3.抛出同步错误<br>说说这个 throw，承诺可以变得更加令人敬畏。假设我们想要在用户注销时 throw 同步错误。这很容易：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user.isLoggedOut()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'user logged out!'</span>); <span class="comment">// throwing a synchronous error!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id];       <span class="comment">// returning a synchronous value!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id);    <span class="comment">// returning a promise!</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Boo, I got an error!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们<code>catch()</code>将得到一个同步错误，如果用户退出，如果将收到的异步错误的任何承诺都将被拒绝。同样，该函数不关心它获得的错误是同步还是异步。</p><p>这特别有用，因为它可以帮助识别开发过程中的诸如编码错误。例如，如果在<code>then()</code>函数内部的任何点，我们执行 <code>JSON.parse()</code>，如果JSON无效，它可能会抛出同步错误。如果是回调，这个错误就会被吞噬，但是有了承诺，我们可以简单地在我们的<code>catch()</code>函数中处理它。</p><h1 id="高级错误"><a href="#高级错误" class="headerlink" title="高级错误"></a>高级错误</h1><p>好吧，既然你已经学会了让承诺变得简单易行的技巧，那就让我们谈谈边缘情况吧。因为当然总有边缘情况。</p><p>我将这些错误归类为“高级”，因为我只看到了那些已经相当擅长承诺的程序员犯的错误。但是，如果希望能够解决本文开头提出的难题，则需要讨论它们。</p><h2 id="高级错误＃1：不知道-Promise-resolve"><a href="#高级错误＃1：不知道-Promise-resolve" class="headerlink" title="高级错误＃1：不知道 Promise.resolve()"></a>高级错误＃1：不知道 Promise.resolve()</h2><p>如上所示，promise 对于将同步代码包装为异步代码非常有用。但是，如果您发现自己很啰嗦地输入了很多内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(someSynchronousValue);</span><br><span class="line">&#125;).then(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure><p>您可以使用以下方式更简洁地表达 Promise.resolve()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(someSynchronousValue).then(/* ... */);</span><br></pre></td></tr></table></figure><p>这对于捕获任何同步错误也非常有用。我养成了几乎所有 API 方法返回承诺的习惯，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">somePromiseAPI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSomethingThatMayThrow();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">  &#125;).then(<span class="comment">/* ... */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>请记住：任何可能同步 throw 的代码都是一个很好的候选者，可以在某此地方找到几乎不可能调试的吞咽错误。但如果你将所有内容都包装在 Promise.resolve()里，那么你可以确保随时catch()它。</p></blockquote><p>同样，Promise.reject() 可以用来返回立即拒绝的承诺：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(new Error(&apos;some awful error&apos;));</span><br></pre></td></tr></table></figure><h2 id="高级错误＃2：-then-resolveHandler-catch-rejectHandler-与-then-resolveHandler-rejectHandler-完全不一样"><a href="#高级错误＃2：-then-resolveHandler-catch-rejectHandler-与-then-resolveHandler-rejectHandler-完全不一样" class="headerlink" title="高级错误＃2： then(resolveHandler).catch(rejectHandler) 与 then(resolveHandler, rejectHandler) 完全不一样"></a>高级错误＃2： then(resolveHandler).catch(rejectHandler) 与 then(resolveHandler, rejectHandler) 完全不一样</h2><p>我上面说<code>catch()</code>的只是糖。所以这两个片段是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">somePromise().catch(function (err) &#123;</span><br><span class="line">  // handle error</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(null, function (err) &#123;</span><br><span class="line">  // handle error</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是，这并不意味着以下两个片段是等效的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(function () &#123;</span><br><span class="line">  return someOtherPromise();</span><br><span class="line">&#125;).catch(function (err) &#123;</span><br><span class="line">  // handle error</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(function () &#123;</span><br><span class="line">  return someOtherPromise();</span><br><span class="line">&#125;, function (err) &#123;</span><br><span class="line">  // handle error</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果您想知道为什么它们不相同，请考虑如果第一个函数抛出错误会发生什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(function () &#123;</span><br><span class="line">  throw new Error(&apos;oh noes&apos;);</span><br><span class="line">&#125;).catch(function (err) &#123;</span><br><span class="line">  // I caught your error! :)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(function () &#123;</span><br><span class="line">  throw new Error(&apos;oh noes&apos;);</span><br><span class="line">&#125;, function (err) &#123;</span><br><span class="line">  // I didn&apos;t catch your error! :(</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事实证明，当你使用then(resolveHandler, rejectHandler)格式时，如果它自己抛出错误，rejectHandler 实际上不会捕获 resolveHandler 的错误。</p><p>出于这个原因，我已经习惯于永远不要使用带第二个参数的 <code>then()</code>，而且总是喜欢<code>catch()</code>。例外情况是我在编写异步<a href="http://mochajs.org/" target="_blank" rel="noopener">Mocha</a>测试时，我可能会编写一个测试来确保抛出错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;should throw an error&apos;, function () &#123;</span><br><span class="line">  return doSomethingThatThrows().then(function () &#123;</span><br><span class="line">    throw new Error(&apos;I expected an error!&apos;);</span><br><span class="line">  &#125;, function (err) &#123;</span><br><span class="line">    should.exist(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>说到这一点，Mocha和<a href="http://chaijs.com/" target="_blank" rel="noopener">Chai</a>是测试承诺 API 的可爱组合。<a href="https://github.com/pouchdb/plugin-seed" target="_blank" rel="noopener">pouchdb-插件种子</a>项目有一些样本测试, 你可以试试。</p><h2 id="高级错误＃3：承诺与承诺工厂"><a href="#高级错误＃3：承诺与承诺工厂" class="headerlink" title="高级错误＃3：承诺与承诺工厂"></a>高级错误＃3：承诺与承诺工厂</h2><p>假设你想按顺序依次执行一系列的承诺。也就是说，你需要类似的东西 Promise.all()，但它不会并行执行承诺。</p><p>你可能天真地写这样的东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function executeSequentially(promises) &#123;</span><br><span class="line">  var result = Promise.resolve();</span><br><span class="line">  promises.forEach(function (promise) &#123;</span><br><span class="line">    result = result.then(promise);</span><br><span class="line">  &#125;);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，这不会按照你的意图行事。你传递给承诺 executeSequentially() 将依然并行执行。</p><p>发生这种情况的原因是你根本不想操作一系列的承诺。根据 promise 规范，一旦创建了 promise，它就会开始执行。所以你真正想要的是一系列承诺工厂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function executeSequentially(promiseFactories) &#123;</span><br><span class="line">  var result = Promise.resolve();</span><br><span class="line">  promiseFactories.forEach(function (promiseFactory) &#123;</span><br><span class="line">    result = result.then(promiseFactory);</span><br><span class="line">  &#125;);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我知道你在想什么：“这个Java程序员到底是谁，他说的是啥工厂呢？” 承诺工厂很简单 - 它只是一个返回承诺的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myPromiseFactory() &#123;</span><br><span class="line">  return somethingThatCreatesAPromise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这样做？它起作用是因为承诺工厂在被调用之前不会创造承诺。它的功能与then功能相同- 事实上，它是一样的！</p><p>如果你看一下上面 executeSequentially() 的功能，然后想象 myPromiseFactory 被替换在里面<code>result.then(...)</code>，那么希望你的大脑会点亮一个灯泡。那一刻，你将获得承诺启蒙。</p><h2 id="高级错误＃4：好的，如果我想要两个承诺的结果怎么办？"><a href="#高级错误＃4：好的，如果我想要两个承诺的结果怎么办？" class="headerlink" title="高级错误＃4：好的，如果我想要两个承诺的结果怎么办？"></a>高级错误＃4：好的，如果我想要两个承诺的结果怎么办？</h2><p>通常，一个承诺将取决于另一个承诺，但我们希望两个承诺的输出。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(&apos;nolan&apos;).then(function (user) &#123;</span><br><span class="line">  return getUserAccountById(user.id);</span><br><span class="line">&#125;).then(function (userAccount) &#123;</span><br><span class="line">  // dangit, I need the &quot;user&quot; object too!</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>想要成为优秀的 JavaScript 开发人员并避免厄运的金字塔，我们可能只是将 user 对象存储在更高范围的变量中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var user;</span><br><span class="line">getUserByName(&apos;nolan&apos;).then(function (result) &#123;</span><br><span class="line">  user = result;</span><br><span class="line">  return getUserAccountById(user.id);</span><br><span class="line">&#125;).then(function (userAccount) &#123;</span><br><span class="line">  // okay, I have both the &quot;user&quot; and the &quot;userAccount&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这有效，但我个人觉得它有点笨拙。我推荐的策略：放下你的先入之见, 并拥抱金字塔：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(&apos;nolan&apos;).then(function (user) &#123;</span><br><span class="line">  return getUserAccountById(user.id).then(function (userAccount) &#123;</span><br><span class="line">    // okay, I have both the &quot;user&quot; and the &quot;userAccount&quot;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>……至少，暂时是这样。如果缩进成为一个问题，那么你可以做JavaScript开发人员自远古以来一直在做的事情，并将函数提取到一个命名函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function onGetUserAndUserAccount(user, userAccount) &#123;</span><br><span class="line">  return doSomething(user, userAccount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function onGetUser(user) &#123;</span><br><span class="line">  return getUserAccountById(user.id).then(function (userAccount) &#123;</span><br><span class="line">    return onGetUserAndUserAccount(user, userAccount);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserByName(&apos;nolan&apos;)</span><br><span class="line">  .then(onGetUser)</span><br><span class="line">  .then(function () &#123;</span><br><span class="line">  // at this point, doSomething() is done, and we are back to indentation 0</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>随着您的承诺代码变得越来越复杂，您可能会发现自己将越来越多的函数提取到命名函数中。我发现这导致了非常美观的代码，可能看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">putYourRightFootIn()</span><br><span class="line">  .then(putYourRightFootOut)</span><br><span class="line">  .then(putYourRightFootIn)  </span><br><span class="line">  .then(shakeItAllAbout);</span><br></pre></td></tr></table></figure><p>这就是承诺的全部意义。</p><h2 id="高级错误＃5：承诺失败"><a href="#高级错误＃5：承诺失败" class="headerlink" title="高级错误＃5：承诺失败"></a>高级错误＃5：承诺失败</h2><p>最后，当我介绍上面的承诺难题时，这是我提到的错误。这是一个非常深奥的用例，它可能永远不会出现在你的代码中，但它确实让我感到惊讶。</p><p>您认为此代码打印出来的是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&apos;foo&apos;).then(Promise.resolve(&apos;bar&apos;)).then(function (result) &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你认为它打印出来bar，你就错了。它实际打印出来foo！</p><p>发生这种情况的原因是因为当你传递then()一个非函数（例如一个promise）时，它实际上将它解释为then(null)，这会导致前一个promise的结果失败。你可以自己测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&apos;foo&apos;).then(null).then(function (result) &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>添加任意数量的then(null)时; 它仍然会打印foo。</p><p>这实际上回到了我之前关于承诺与承诺工厂的观点。简而言之，您可以将承诺直接传递给then()方法，但它不会按照您的想法执行。要给then()以函数作为参数，所以你最有可能这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&apos;foo&apos;).then(function () &#123;</span><br><span class="line">  return Promise.resolve(&apos;bar&apos;);</span><br><span class="line">&#125;).then(function (result) &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>正如我们所料，这将打印出来<code>bar</code>。</p><p>所以只需提醒自己：总是将函数传递给then()！</p><h1 id="解决这个难题"><a href="#解决这个难题" class="headerlink" title="解决这个难题"></a>解决这个难题</h1><p>现在我们已经学会了所有关于承诺的知识（或接近它！），我们应该能够解决我在本文开头提出的难题。</p><p>以下是每个图形格式的答案，以便您可以更好地将其可视化：</p><h2 id="拼图＃1"><a href="#拼图＃1" class="headerlink" title="拼图＃1"></a>拼图＃1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(function () &#123;</span><br><span class="line">  return doSomethingElse();</span><br><span class="line">&#125;).then(finalHandler);</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(undefined)</span><br><span class="line">                  |------------------|</span><br><span class="line">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                     |------------------|</span><br></pre></td></tr></table></figure><h2 id="拼图＃2"><a href="#拼图＃2" class="headerlink" title="拼图＃2"></a>拼图＃2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(function () &#123;</span><br><span class="line">  doSomethingElse();</span><br><span class="line">&#125;).then(finalHandler);</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(undefined)</span><br><span class="line">                  |------------------|</span><br><span class="line">                  finalHandler(undefined)</span><br><span class="line">                  |------------------|</span><br></pre></td></tr></table></figure><h2 id="拼图＃3"><a href="#拼图＃3" class="headerlink" title="拼图＃3"></a>拼图＃3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(doSomethingElse())</span><br><span class="line">  .then(finalHandler);</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">doSomethingElse(undefined)</span><br><span class="line">|---------------------------------|</span><br><span class="line">                  finalHandler(resultOfDoSomething)</span><br><span class="line">                  |------------------|</span><br></pre></td></tr></table></figure><h2 id="拼图＃4"><a href="#拼图＃4" class="headerlink" title="拼图＃4"></a>拼图＃4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(doSomethingElse)</span><br><span class="line">  .then(finalHandler);</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(resultOfDoSomething)</span><br><span class="line">                  |------------------|</span><br><span class="line">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                     |------------------|</span><br></pre></td></tr></table></figure><p>如果对这些问题的答案仍然没感觉，那么我建议你重新阅读后，或定义doSomething()和doSomethingElse()方法，并自己在浏览器中试一下。</p><blockquote><p>澄清：这些例子中，我假定这两个doSomething()与doSomethingElse()返回的承诺，而这些承诺代表东西在 JavaScript 事件循环之外进行（例如索引资料，网络，<code>setTimeout</code>），这就是为什么他们显示为同时是合适的。这里有一个<a href="http://jsbin.com/tuqukakawo/1/edit?js,console,output" target="_blank" rel="noopener">JSBin</a>演示。</p></blockquote><p>而对于承诺的更高级用途，请查看我的承诺<a href="https://gist.github.com/nolanlawson/6ce81186421d2fa109a4" target="_blank" rel="noopener">protip</a>备忘单。</p><h1 id="关于承诺的最后一句话"><a href="#关于承诺的最后一句话" class="headerlink" title="关于承诺的最后一句话"></a>关于承诺的最后一句话</h1><p>承诺很棒。如果您仍在使用回调，我强烈建议您切换到承诺。您的代码将变得更小，更优雅，更容易推理。</p><p>如果你不相信我，这就是证明：PouchDB的 map/reduce 模块的<a href="https://t.co/hRyc6ENYGC" target="_blank" rel="noopener">重构</a>用 promis 代替回调。结果：290次插入，555次删除。</p><p>顺便说一下，写那个令人讨厌的回调代码的人是……我！所以这是我在承诺的原始力量中的第一课，我感谢其他PouchDB贡献者一路上指导我。</p><p>话虽如此，承诺并不完美。确实，他们比回调更好，但这就像说冲击肠道比踢牙齿更好。当然，一个比另一个更好，但如果你有选择，你可能会避免它们。</p><p>虽然优于回调，但承诺仍然难以理解且容易出错，正如我觉得有必要写这篇博文一样。新手和专家都会经常弄乱这些东西，真的，这不是他们的错。问题是承诺虽然类似于我们在同步代码中使用的模式，但却是一个不错的替代品，但并不完全相同。</p><p>事实上，你不应该学一堆神秘的规则和新的API搞这样的事情，在同步的世界里，你可以用熟悉的模式，比如行为很清楚return，catch，throw，和for循环。不应该有两个并行系统，你必须始终保持在脑海中。</p><h1 id="等待异步-等待"><a href="#等待异步-等待" class="headerlink" title="等待异步/等待"></a>等待异步/等待</h1><p>这就是我在“<a href="http://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html" target="_blank" rel="noopener">用ES7驯服异步野兽</a>”中提出的观点，我探讨了ES7 async/await 关键词，以及它们如何将承诺更深入地融入到语言中。与我们在CS 101中学到的一样，ES7不是必须编写伪同步代码（使用假的catch()方法catch，但实际上并非如此），而是允许我们使用真实的 try/catch/return 关键字。</p><p>这对JavaScript作为一种语言来说是一个巨大的福音。因为最终，只要我们的工具没有告诉我们什么时候出错，这些承诺反模式仍将继续出现。</p><p>要采取从JavaScript的历史上的例子，我认为这是公平地说，<a href="http://jslint.com/" target="_blank" rel="noopener">JSLint</a>的和<a href="http://jshint.com/" target="_blank" rel="noopener">JSHint</a>为社区提供了比 JavaScript 好的服务：好的方面，即使它们有效地遏制了相同的信息。这就是告诉你刚才在代码中犯的错误，而不是读一本你试图理解其他人的错误的书。</p><p>ES7 async/await 的优点在于，在大多数情况下，您的错误会将自己显示为语法/编译器错误，而不是微妙的运行时错误。但是，在那之前，掌握承诺的能力，以及如何在ES5和ES6中正确使用它们是件好事。</p><p>因此，虽然我认识到，像<a href="http://amzn.com/0596517742" target="_blank" rel="noopener">JavaScript：The Good Parts</a>，这篇博文只会产生有限的影响，但是当你看到他们犯同样的错误时，你可以指出这些东西。因为我们中有太多人还需要承认：“我对承诺有疑问！”</p><blockquote><p>更新：有人向我指出，Bluebird 3.0将打印出可以防止我在本文中发现的许多错误的警告。所以当我们等待ES7时，使用Bluebird是另一个很好的选择！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-Promise-–-承诺之困惑&quot;&gt;&lt;a href=&quot;#JavaScript-Promise-–-承诺之困惑&quot; class=&quot;headerlink&quot; title=&quot;JavaScript Promise – 承诺之困惑&quot;&gt;&lt;/a&gt;JavaScri
      
    
    </summary>
    
    
      <category term="javascript promise" scheme="http://s.bixuebihui.cn/tags/javascript-promise/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 8.0 remove query cache</title>
    <link href="http://s.bixuebihui.cn/2019/08/27/MySQL-8-0-remove-query-cache/"/>
    <id>http://s.bixuebihui.cn/2019/08/27/MySQL-8-0-remove-query-cache/</id>
    <published>2019-08-27T00:54:39.000Z</published>
    <updated>2019-08-27T01:32:17.424Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 8.0：停用对查询缓存的支持<br>2017年5月30 日MySQL Matt Lord<br>正如Rene昨天在ProxySQL博客上写道：</p><blockquote><p>尽管MySQL Query Cache旨在提高性能，但它存在严重的可伸缩性问题，并且很容易成为严重的瓶颈。</p></blockquote><p>这确实是我们在MySQL团队中观察到的一段时间。在我们讨论今天发表的主题之前，让我先介绍一下。</p><h1 id="查询缓存简介"><a href="#查询缓存简介" class="headerlink" title="查询缓存简介"></a>查询缓存简介</h1><p>MySQL 查询缓存是查询结果缓存。它将以<code>SEL</code>开头的传入查询与哈希表进行比较，如果匹配则返回先前执行查询的结果。有一些限制：</p><ul><li>查询必须逐字节匹配（查询缓存避免解析）</li><li>使用非确定性功能将导致查询未被缓存（包括临时表，用户变量，RAND（），NOW（）和UDF。）</li><li>查询缓存旨在不提供过时的结果。对基础表的任何修改都会导致所有缓存对这些表无效。</li><li>如果缓存可用于InnoDB，则存在一些限制（尊重MVCC;因为您打开了事务，’缓存’可能不代表预期视图中的数据。）</li></ul><h1 id="最佳案例情景"><a href="#最佳案例情景" class="headerlink" title="最佳案例情景"></a>最佳案例情景</h1><p>正如我几年前在我的个人博客上写的那样：</p><blockquote><p>查询缓存的理想情况往往是大部分是只读的，其中有许多非常昂贵的查询只检查数百万行以返回一些。假设示例可能是一个复杂的查询，用于为始终显示在网页表单上的下拉列表构建值列表。在这种情况下，查询缓存可以掩盖由丢失索引引起的性能问题，这使得它对新手用户很有帮助。</p></blockquote><p>今天这个评论仍然是正确的，但我认为重要的是还要指出用于不良应用干预的DBA工具也有所改进：</p><p>在MySQL服务器中，我们现在能够重写查询以插入提示（或其他修改以提高性能）<br>我们有像 ProxySQL 这样的第三方工具，可以充当中间人查询缓存。ProxySQL 还支持缓存的TTL，它在我之前提供的示例中工作正常（为下拉列表构建值列表）。</p><h1 id="查询缓存的局限性"><a href="#查询缓存的局限性" class="headerlink" title="查询缓存的局限性"></a>查询缓存的局限性</h1><p>自MySQL 5.6（2013）以来，默认情况下已禁用查询缓存，因为众所周知，它不能与多核计算机上的高吞吐量工作负载进行扩展。Rene昨天在他的帖子中证实了这一点，但<a href="https://www.flamingspork.com/blog/2014/06/05/performance-impact-of-mysql-query-cache-on-modern-hardware/" target="_blank" rel="noopener">Stewart Smith</a>，  <a href="https://dom.as/tech/query-cache-tuner/" target="_blank" rel="noopener">Domas Mituzas</a>  （更新：和Kristian Koehntopp）之前也曾提到过这一点。</p><p>假设可以提高可伸缩性，查询缓存的限制因素是，因为只有访问缓存的查询才会看到改进; 它不太可能提高绩效的可预测性。  对于面向用户的系统，降低性能的可变性通常比提高峰值吞吐量更重要：</p><p><img src="Predictability-SIGMOD2017-768x576.jpg" alt="从自顶向下的方法中滑动2/47 以实现数据库系统中的性能可预测性。"></p><p><img src="Predictability-SIGMOD2017-2-768x576.jpg" alt="从自上而下的方法中滑动3/47 以实现数据库系统中的性能可预测性。"></p><h1 id="决定删除对查询缓存的支持"><a href="#决定删除对查询缓存的支持" class="headerlink" title="决定删除对查询缓存的支持"></a>决定删除对查询缓存的支持</h1><p>我们同意密歇根大学安娜堡分校的Jiamin Huang，Barzan Mozafari，Grant Schoenebeck，Thomas F. Wenisch所做的<a href="http://web.eecs.umich.edu/~mozafari/php/data/uploads/Predictability-SIGMOD2017.pdf" target="_blank" rel="noopener">研究</a>。我们考虑了我们可以对查询缓存进行哪些改进，以及我们可以进行的优化，这些优化可以改善所有工作负载。</p><p>虽然这些选择本身是正交的，但工程资源是有限的。也就是说，我们正在转变战略，投资于更普遍适用于所有工作负载的改进。</p><p>我们也同意Rene的<a href="http://proxysql.com/blog/scaling-with-proxysql-query-cache" target="_blank" rel="noopener">结论</a>，即当它靠近客户端时，缓存提供了最大的好处：</p><p><img src="QC2.png" alt="proxysql"></p><p>“Client + 2x ProxySQL”结果显示，在将缓存移动到客户端时，性能提高了5.2倍。</p><h1 id="现有用户的升级路径"><a href="#现有用户的升级路径" class="headerlink" title="现有用户的升级路径"></a>现有用户的升级路径</h1><p>根据当前的限制，MySQL 5.7的生命周期将继续支持查询缓存。MySQL 8.0不支持查询缓存，并且鼓励用户升级使用服务器端Query Rewrite或ProxySQL作为中间人缓存。</p><p>我们希望此更改只会影响少数用户，但如果您对此感兴趣，请与我们联系并取消联系！</p><p>感谢您使用MySQL！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL 8.0：停用对查询缓存的支持&lt;br&gt;2017年5月30 日MySQL Matt Lord&lt;br&gt;正如Rene昨天在ProxySQL博客上写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;尽管MySQL Query Cache旨在提高性能，但它存在严重的可伸缩性问题
      
    
    </summary>
    
    
      <category term="mysql cache" scheme="http://s.bixuebihui.cn/tags/mysql-cache/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript function vs Function</title>
    <link href="http://s.bixuebihui.cn/2019/08/23/JavaScript-function-vs-Function/"/>
    <id>http://s.bixuebihui.cn/2019/08/23/JavaScript-function-vs-Function/</id>
    <published>2019-08-23T10:52:54.000Z</published>
    <updated>2019-08-23T10:56:45.421Z</updated>
    
    <content type="html"><![CDATA[<p>function, new function, new Function之间的区别</p><p>函数是JavaScript中很重要的一个语言元素，并且提供了一个function关键字和内置对象Function，下面是其可能的用法和它们之间的关系。</p><h1 id="使用方法一"><a href="#使用方法一" class="headerlink" title="使用方法一"></a>使用方法一</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo01 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) //<span class="title">or</span> <span class="title">fun01</span> = <span class="title">function</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">var</span> temp = <span class="number">100</span>; </span><br><span class="line">    <span class="keyword">this</span>.temp = <span class="number">200</span>; </span><br><span class="line">    <span class="keyword">return</span> temp + <span class="keyword">this</span>.temp; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">alert(<span class="keyword">typeof</span>(foo01)); </span><br><span class="line">alert(foo01());</span><br></pre></td></tr></table></figure><p> 运行结果：</p><blockquote><p>function<br> 300    </p></blockquote><p>最普通的function使用方式，定一个JavaScript函数。两种写法表现出来的运行效果完全相同，唯一的却别是后一种写法有较高的初始化优先级。在大扩号内的变量作用域中，this指代foo01的所有者，即window对象。</p><h1 id="使用方法二"><a href="#使用方法二" class="headerlink" title="使用方法二"></a>使用方法二</h1><p>代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo02 = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line">     <span class="keyword">var</span> temp = <span class="number">100</span>; </span><br><span class="line">     <span class="keyword">this</span>.temp = <span class="number">200</span>; </span><br><span class="line">     <span class="keyword">return</span> temp + <span class="keyword">this</span>.temp; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> alert(<span class="keyword">typeof</span>(foo02)); </span><br><span class="line"> alert(foo02.constructor());</span><br></pre></td></tr></table></figure><p>运行结果：  </p><blockquote><p>object<br> 300    </p></blockquote><p>这是一个比较puzzle的function的使用方式，好像是定一个函数。但是实际上这是定一个JavaScript中的用户自定义对象，不过这里是个匿名类。这个用法和函数本身的使用基本没有任何关系，在大扩号中会构建一个变量作用域，this指代这个作用域本身。</p><h1 id="使用方法三"><a href="#使用方法三" class="headerlink" title="使用方法三"></a>使用方法三</h1><p>代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'var temp = 100; this.temp = 200; return temp + this.temp;'</span>); </span><br><span class="line"></span><br><span class="line"> alert(<span class="keyword">typeof</span>(foo3)); </span><br><span class="line"> alert(foo3());</span><br></pre></td></tr></table></figure><p>运行结果：  </p><blockquote><p>function<br> 300    </p></blockquote><p>使用系统内置函数对象来构建一个函数，这和方法一中的第一种方式在效果和初始化优先级上都完全相同，就是函数体以字符串形式给出。</p><h1 id="使用方法四"><a href="#使用方法四" class="headerlink" title="使用方法四"></a>使用方法四</h1><p>代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo4 = <span class="built_in">Function</span>(<span class="string">'var temp = 100; this.temp = 200; return temp + this.temp;'</span>); </span><br><span class="line"></span><br><span class="line"> alert(<span class="keyword">typeof</span>(foo4)); </span><br><span class="line"> alert(foo4());</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>function<br>300    </p></blockquote><p>这个方式是不常使用的，效果和方法三一样，这也体现了JavaScript一个最大的特性：灵活！能省就省。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;function, new function, new Function之间的区别&lt;/p&gt;
&lt;p&gt;函数是JavaScript中很重要的一个语言元素，并且提供了一个function关键字和内置对象Function，下面是其可能的用法和它们之间的关系。&lt;/p&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
    
      <category term="JavaScript function" scheme="http://s.bixuebihui.cn/tags/JavaScript-function/"/>
    
  </entry>
  
  <entry>
    <title>http cache control</title>
    <link href="http://s.bixuebihui.cn/2019/08/23/http-cache-control/"/>
    <id>http://s.bixuebihui.cn/2019/08/23/http-cache-control/</id>
    <published>2019-08-23T04:50:54.000Z</published>
    <updated>2019-08-23T04:59:32.271Z</updated>
    
    <content type="html"><![CDATA[<p>面向站长和网站管理员的Web缓存加速指南[翻译]</p><p>原文（英文）地址： <a href="http://www.mnot.net/cache_docs/" target="_blank" rel="noopener">http://www.mnot.net/cache_docs/</a>  版权声明：署名-非商业性使用-禁止演绎 2.0</p><p>这是一篇知识性的文档，主要目的是为了让Web缓存相关概念更容易被开发者理解并应用于实际的应用环境中。为了简要起见，某些实现方面的细节被简化或省略了。如果你更关心细节实现则完全不必耐心看完本文，后面参考文档和更多深入阅读部分可能是你更需要的内容。</p><p>什么是Web缓存，为什么要使用它？<br>缓存的类型：<br>浏览器缓存；<br>代理服务器缓存；<br>Web缓存无害吗？为什么要鼓励缓存？<br>Web缓存如何工作：<br>如何控制（控制不）缓存：<br>HTML Meta标签 vs. HTTP头信息；<br>Pragma HTTP头信息（为什么不起作用）；<br>使用Expires（过期时间）HTTP头信息控制保鲜期；<br>Cache-Control（缓存控制） HTTP头信息；<br>校验参数和校验；<br>创建利于缓存网站的窍门；<br>编写利于缓存的脚本；<br>常见问题解答；<br>缓存机制的实现：Web服务器端配置；<br>缓存机制的实现：服务器端脚本；<br>参考文档和深入阅读；<br>关于本文档；</p><h1 id="什么是Web缓存，为什么要使用它？"><a href="#什么是Web缓存，为什么要使用它？" class="headerlink" title="什么是Web缓存，为什么要使用它？"></a>什么是Web缓存，为什么要使用它？</h1><p>Web缓存位于Web服务器之间（1个或多个，内容源服务器）和客户端之间（1个或多个）：缓存会根据进来的请求保存输出内容的副本，例如html页面， 图片，文件（统称为副本），然后，当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。</p><p>使用缓存主要有2大理由：<br>减少相应延迟：因为请求从缓存服务器（离客户端更近）而不是源服务器被相应，这个过程耗时更少，让web服务器看上去相应更快；<br>减少网络带宽消耗：当副本被重用时会减低客户端的带宽消耗；客户可以节省带宽费用，控制带宽的需求的增长并更易于管理。<br>缓存的类型<br>浏览器缓存<br>对于新一代的Web浏览器来说（例如：IE，Firefox）：一般都能在设置对话框中发现关于缓存的设置，通过在你的电脑上僻处一块硬盘空间用于存储你已经看过的网站的副本。浏览器缓存根据非常简单的规则进行工作：在同一个会话过程中（在当前浏览器没有被关闭之前）会检查一次并确定缓存的副本足够新。这个缓存对于用户点击“后退”或者点击刚访问过的链接特别有用，如果你浏览过程中访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现。</p><h1 id="代理服务器缓存"><a href="#代理服务器缓存" class="headerlink" title="代理服务器缓存"></a>代理服务器缓存</h1><p>Web代理服务器使用同样的缓存原理，只是规模更大。代理服务器群为成百上千用户服务使用同样的机制；大公司和ISP经常在他们的防火墙上架设代理缓存或者单独的缓存设备；</p><p>由于带路服务器缓存并非客户端或者源服务器的一部分，而是位于原网络之外，请求必须路由到他们才能起作用。一个方法是手工设置你的浏览器：告诉浏览器使用 那个代理，另外一个是通过中间服务器：这个中间服务器处理所有的web请求，并将请求转发到后台网络，而用户不必配置代理，甚至不必知道代理的存在；</p><p>代理服务器缓存：是一个共享缓存，不只为一个用户服务，经常为大量用户使用，因此在减少相应时间和带宽使用方面很有效：因为同一个副本会被重用多次。<br>网关缓存<br>也被称为反向代理缓存或间接代理缓存，网关缓存也是一个中间服务器，和内网管理员部署缓存用于节省带宽不同：网关缓存一般是网站管理员自己部署：让他们的网站更容易扩展并获得更好的性能；<br>请求有几种方法被路由到网关缓存服务器上：其中典型的是让用一台或多台负载均衡服务器从客户端看上去是源服务器；</p><p>网络内容发布商  (Content delivery networks CDNs)分布网关缓存到整个（或部分）互联网上，并出售缓存服务给需要的网站，Speedera和Akamai就是典型的网络内容发布商(下文简称CDN)。</p><p>本问主要关注于浏览器和代理缓存，当然，有些信息对于网关缓存也同样有效；</p><h1 id="Web缓存无害吗？为什么要鼓励缓存？"><a href="#Web缓存无害吗？为什么要鼓励缓存？" class="headerlink" title="Web缓存无害吗？为什么要鼓励缓存？"></a>Web缓存无害吗？为什么要鼓励缓存？</h1><p>Web缓存在互联网上最容易被误解的技术之一：网站管理员经常怕对网站失去控制，由于代理缓存会“隐藏”他们的用户，让他们感觉难以监控谁在使用他们的网站。<br>不幸的是：就算不考虑Web缓存，互联网上也有很多网站使用非常多的参数以便管理员精确地跟踪用户如何使用他们的网站；如果这类问题也是你关心的，本文将告诉你如何获得精确的统计而不必将网站设计的非常缓存不友好。<br>另外一个抱怨是缓存会给用户过期或失效的数据；无论如何：本文可以告诉你怎样配置你的服务器来控制你的内容将被如何缓存。</p><p>CDN是另外一个有趣的方向，和其他代理缓存不同：CDN的网关缓存为希望被缓存的网站服务，没有以上顾虑。即使你使用了CDN，你也要考虑后续的代理服务器缓存和浏览器缓存问题。</p><p>另外一方面：如果良好地规划了你的网站，缓存会有助于网站服务更快，并节省服务器负载和互联网的链接请求。这个改善是显著的：一个难以缓存的网站可能需要几秒去载入页面，而对比有缓存的网站页面几乎是即时显现：用户更喜欢速度快的网站并更经常的访问；</p><p>这样想：很多大型互联网公司为全世界服务器群投入上百万资金，为的就是让用户访问尽可能快，客户端缓存也是这个目的，只不过更靠近用户一端，而且最好的一点是你甚至根本不用为此付费。</p><p>事实上，无论你是否喜欢，代理服务器和浏览器都回启用缓存。如果你没有配置网站正确的缓存，他们会按照缺省或者缓存管理员的策略进行缓存。</p><h1 id="缓存如何工作"><a href="#缓存如何工作" class="headerlink" title="缓存如何工作"></a>缓存如何工作</h1><p>所有的缓存都用一套规则来帮助他们决定什么时候使用缓存中的副本提供服务（假设有副本可用的情况下）；一些规则在协议中有定义（HTTP协议1.0和1.1），一些规则由缓存的管理员设置（浏览器的用户或者代理服务器的管理员）；<br>一般说来：遵循以下基本的规则（不必担心，你不必知道所有的细节，细节将随后说明）</p><p>如果响应头信息：告诉缓存器不要保留缓存，缓存器就不会缓存相应内容；<br>如果请求信息是需要认证或者安全加密的，相应内容也不会被缓存；<br>如果在回应中不存在校验器（ETag或者Last-Modified头信息），缓存服务器会认为缺乏直接的更新度信息，内容将会被认为不可缓存。<br>一个缓存的副本如果含有以下信息：内容将会被认为是足够新的<br>含有完整的过期时间和寿命控制头信息，并且内容仍在保鲜期内；<br>浏览器已经使用过缓存副本，并且在一个会话中已经检查过内容的新鲜度；<br>缓存代理服务器近期内已经使用过缓存副本，并且内容的最后更新时间在上次使用期之前；<br>够新的副本将直接从缓存中送出，而不会向源服务器发送请求；<br>如果缓存的副本已经太旧了，缓存服务器将向源服务器发出请求校验请求，用于确定是否可以继续使用当前拷贝继续服务；<br>总之：新鲜度和校验是确定内容是否可用的最重要途径：</p><p>如果副本足够新，从缓存中提取就立刻能用了；<br>而经缓存器校验后发现副本的原件没有变化，系统也会避免将副本内容从源服务器整个重新传输一遍。</p><h1 id="如何控制（控制不）缓存"><a href="#如何控制（控制不）缓存" class="headerlink" title="如何控制（控制不）缓存"></a>如何控制（控制不）缓存</h1><p>有很多工具可以帮助设计师和网站管理员调整缓存服务器对待网站的方式，这也许需要你亲自下手对服务器的配置进行一些调整，但绝对值得；了解如何使用这些工具请参考后面的实现章节；</p><p>HTML meta标签和HTTP 头信息<br>HTML的编写者会在文档的<code>&lt;HEAD&gt;</code>区域中加入描述文档的各种属性，这些META标签常常被用于标记文档不可以被缓存或者标记多长时间后过期；<br>META标签使用很简单：但是效率并不高，因为只有几种浏览器会遵循这个标记（那些真正会“读懂”HTML的浏览器），没有一种缓存代理服务器能遵循这个 规则（因为它们几乎完全不解析文档中HTML内容）；有事会在Web页面中增加：Pragma: no-cache这个META标记，如果要让页面保持刷新，这个标签其实完全没有必要。<br>如果你的网站托管在ISP机房中，并且机房可能不给你权限去控制HTTP的头信息（如：Expires和Cache-Control），大声控诉：这些机制对于你的工作来说是必须的；<br>另外一方面： HTTP头信息可以让你对浏览器和代理服务器如何处理你的副本进行更多的控制。他们在HTML代码中是看不见的，一般由Web服务器自动生成。但是，根据 你使用的服务，你可以在某种程度上进行控制。在下文中：你将看到一些有趣的HTTP头信息，和如何在你的站点上应用部署这些特性。</p><p>HTTP头信息发送在HTML代码之前，只有被浏览器和一些中间缓存能看到，一个典型的HTTP 1.1协议返回的头信息看上去像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 30 Oct 1998 13:19:41 GMT</span><br><span class="line">Server: Apache/1.3.3 (Unix)</span><br><span class="line">Cache-Control: max-age=3600, must-revalidate</span><br><span class="line">Expires: Fri, 30 Oct 1998 14:19:41 GMT</span><br><span class="line">Last-Modified: Mon, 29 Jun 1998 02:28:12 GMT</span><br><span class="line">ETag: &quot;3e86-410-3596fbbc&quot;</span><br><span class="line">Content-Length: 1040</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure><p>在头信息空一行后是HTML代码的输出，关于如何设置HTTP头信息请参考实现章节；</p><p>Pragma HTTP头信息 (为什么它不起作用)<br>很多人认为在HTTP头信息中设置了Pragma: no-cache后会让内容无法被缓存。但事实并非如此：HTTP的规范中，响应型头信息没有任何关于Pragma属性的说明，而讨论了的是请求型头信息 Pragma属性（头信息也由浏览器发送给服务器），虽然少数集中缓存服务器会遵循这个头信息，但大部分不会。用了Pragma也不起什么作用，要用就使 用下列头信息：</p><p>使用Expires（过期时间）HTTP头信息来控制保鲜期<br>Expires（过期时间） 属性是HTTP控制缓存的基本手段，这个属性告诉缓存器：相关副本在多长时间内是新鲜的。过了这个时间，缓存器就会向源服务器发送请求，检查文档是否被修改。几乎所有的缓存服务器都支持Expires（过期时间）属性；</p><p>大部分Web服务器支持你用几种方式设置Expires属性；一般的：可以设计一个绝对时间间隔：基于客户最后查看副本的时间（最后访问时间）或者根据服务器上文档最后被修改的时间；</p><p>Expires头信息：对于设置静态图片文件（例如导航栏和图片按钮）可缓存特别有用；因为这些图片修改很少，你可以给它们设置一个特别长的过期时间，这会使你的网站对用户变得相应非常快；他们对于控制有规律改变的网页也很有用，例如：你每天早上6点更新新闻页，你可以设置副本的过期时间也是这个时间，这样缓存 服务器就知道什么时候去取一个更新版本，而不必让用户去按浏览器的“刷新”按钮。</p><p>过期时间头信息属性值只能是HTTP格式的日期时间，其他的都会被解析成当前时间“之前”，副本会过期，记住：HTTP的日期时间必须是格林威治时间（GMT），而不是本地时间。举例：</p><p>Expires: Fri, 30 Oct 1998 14:19:41 GMT<br>所以使用过期时间属性一定要确认你的Web服务器时间设置正确，一个途径是通过网络时间同步协议（Network Time Protocol NTP），和你的系统管理员那里你可以了解更多细节。<br>虽然过期时间属性非常有用，但是它还是有些局限，首先：是牵扯到了日期，这样Web服务器的时间和缓存服务器的时间必须是同步的，如果有些不同步，要么是应该缓存的内容提前过期了，要么是过期结果没及时更新。<br>还有一个过期时间设置的问题也不容忽视：如果你设置的过期时间是一个固定的时间，如果你返回内容的时候又没有连带更新下次过期的时间，那么之后所有访问请求都会被发送给源Web服务器，反而增加了负载和响应时间；</p><h1 id="Cache-Control（缓存控制）-HTTP头信息"><a href="#Cache-Control（缓存控制）-HTTP头信息" class="headerlink" title="Cache-Control（缓存控制） HTTP头信息"></a>Cache-Control（缓存控制） HTTP头信息</h1><p>HTTP 1.1介绍了另外一组头信息属性：Cache-Control响应头信息，让网站的发布者可以更全面的控制他们的内容，并定位过期时间的限制。<br>有用的 Cache-Control响应头信息包括：</p><ul><li>max-age=[秒] — 执行缓存被认为是最新的最长时间。类似于过期时间，这个参数是基于请求时间的相对时间间隔，而不是绝对过期时间，[秒]是一个数字，单位是秒：从请求时间开始到过期时间之间的秒数。</li><li>s-maxage=[秒] — 类似于max-age属性，除了他应用于共享（如：代理服务器）缓存</li><li>public — 标记认证内容也可以被缓存，一般来说： 经过HTTP认证才能访问的内容，输出是自动不可以缓存的；</li><li>no-cache — 强制每次请求直接发送给源服务器，而不经过本地缓存版本的校验。这对于需要确认认证应用很有用（可以和public结合使用），或者严格要求使用最新数据的应用（不惜牺牲使用缓存的所有好处）；</li><li>no-store — 强制缓存在任何情况下都不要保留任何副本</li><li>must-revalidate — 告诉缓存必须遵循所有你给予副本的新鲜度的，HTTP允许缓存在某些特定情况下返回过期数据，指定了这个属性，你告诉缓存，你希望严格的遵循你的规则。</li><li>proxy-revalidate — 和 must-revalidate类似，除了他只对缓存代理服务器起作用</li></ul><p>举例:</p><pre><code>Cache-Control: max-age=3600, must-revalidate</code></pre><p>如果你计划试用Cache-Control属性，你应该看一下这篇HTTP文档，详见参考和深入阅读；</p><h1 id="校验参数和校验"><a href="#校验参数和校验" class="headerlink" title="校验参数和校验"></a>校验参数和校验</h1><p>在Web缓存如何工作： 我们说过：校验是当副本已经修改后，服务器和缓存之间的通讯机制；使用这个机制：缓存服务器可以避免副本实际上仍然足够新的情况下重复下载整个原件。<br>校验参数非常重要，如果1个不存在，并且没有任何信息说明保鲜期（Expires或Cache-Control）的情况下，缓存将不会存储任何副本；<br>最常见的校验参数是文档的最后修改时间，通过最后Last-Modified头信息可以，当一份缓存包含Last-Modified信息，他基于此信息，通过添加一个If-Modified-Since请求参数，向服务器查询：这个副本从上次查看后是否被修改了。<br>HTTP 1.1介绍了另外一个校验参数： ETag，服务器是服务器生成的唯一标识符ETag，每次副本的标签都会变化。由于服务器控制了ETag如何生成，缓存服务器可以通过If-None-Match请求的返回没变则当前副本和原件完全一致。<br>所有的缓存服务器都使用Last-Modified时间来确定副本是否够新，而ETag校验正变得越来越流行；<br>所有新一代的Web服务器都对静态内容（如：文件）自动生成ETag和Last-Modified头信息，而你不必做任何设置。但是，服务器对于动态内容（例如：CGI,ASP或数据库生成的网站）并不知道如何生成这些信息，参考一下编写利于缓存的脚本章节；</p><h1 id="创建利于缓存网站的窍门"><a href="#创建利于缓存网站的窍门" class="headerlink" title="创建利于缓存网站的窍门"></a>创建利于缓存网站的窍门</h1><p>除了使用新鲜度信息和校验，你还有很多方法使你的网站缓存友好。</p><p>保持URL稳定： 这是缓存的金科玉律，如果你给在不同的页面上，给不同用户或者从不同的站点上提供相同的内容，应该使用相同的URL，这是使你的网站缓存友好最简单，也是 最高效的方法。例如：如果你在页面上使用 “/index.html” 做为引用，那么就一直用这个地址；<br>使用一个共用的库存放每页都引用的图片和其他页面元素；<br>对于不经常改变的图片/页面启用缓存，并使用Cache-Control: max-age属性设置一个较长的过期时间；<br>对于定期更新的内容设置一个缓存服务器可识别的max-age属性或过期时间；<br>如果数据源（特别是下载文件）变更，修改名称，这样：你可以让其很长时间不过期，并且保证服务的是正确的版本；而链接到下载文件的页面是一个需要设置较短过期时间的页面。<br>万不得已不要改变文件，否则你会提供一个非常新的Last-Modified日期；例如：当你更新了网站，不要复制整个网站的所有文件，只上传你修改的文件。<br>只在必要的时候使用Cookie，cookie是非常难被缓存的，而且在大多数情况下是不必要的，如果使用cookie，控制在动态网页上；<br>减少试用SSL，加密的页面不会被任何共享缓存服务器缓存，只在必要的时候使用，并且在SSL页面上减少图片的使用；<br>使用可缓存性评估引擎，这对于你实践本文的很多概念都很有帮助；<br>编写利于缓存的脚本<br>脚本缺省不会返回校验参数（返回Last-Modified或ETag头信息）或其他新鲜度信息（Expires或Cache-Control），有些动态脚本的确是动态内容（每次相应内容都不一样），但是更多（搜索引擎，数据库引擎网站）网站还是能从缓存友好中获益的。<br>一般说来，如果脚本生成的输出在未来一段时间（几分钟或者几天）都是可重复复制的，那么就是可缓存的。如果脚本输出内容只随URL变化而变化，也是可缓存的；但如果输出会根据cookie，认证信息或者其他外部条件变化，则还是不可缓存的。<br>最利于缓存的脚本就是将内容改变时导出成静态文件，Web服务器可以将其当作另外一个网页并生成和试用校验参数，让一些都变得更简单，只需要写入文件即可，这样最后修改时间也有了；<br>另外一个让脚本可缓存的方法是对一段时间内能保持较新的内容设置一个相对寿命的头信息，虽然通过Expires头信息也可以实现，但更容易的是用Cache-Control: max-age属性，它会让首次请求后一段时间内缓存保持新鲜；<br>如果以上做法你都做不到，你可以让脚本生成一个校验属性，并对 If-Modified-Since 和/或If-None-Match请求作出反应，这些属性可以从解析HTTP头信息得到，并对符合条件的内容返回304 Not Modified（内容未改变），可惜的是，这种做法比不上前2种高效；<br>其他窍门：</p><p>尽量避免使用POST，除非万不得已，POST模式的返回内容不会被大部分缓存服务器保存，如果你发送内容通过URL和查询（通过GET模式）的内容可以缓存下来供以后使用；<br>不要在URL中加入针对每个用户的识别信息：除非内容是针对每个用户不同的；<br>不要统计一个用户来自一个地址的所有请求，因为缓存常常是一起工作的；<br>生成并返回Content-Length头信息，如果方便的话，这个属性让你的脚本在可持续链接模式时：客户端可以通过一个TCP/IP链接同时请求多个副本，而不是为每次请求单独建立链接，这样你的网站相应会快很多；</p><p>具体定义请参考实现章节。</p><h1 id="常见问题解答"><a href="#常见问题解答" class="headerlink" title="常见问题解答"></a>常见问题解答</h1><p>让网站变得可缓存的要点是什么？<br>好的策略是确定那些内容最热门，大量的复制（特别是图片）并针对这些内容先部署缓存。<br>如何让页面通过缓存达到最快相应？<br>缓存最好的副本是那些可以长时间保持新鲜的内容；基于校验虽然有助于加快相应，但是它不得不和源服务器联系一次去检查内容是否够新，如果缓存服务器上就知道内容是新的，内容就可以直接相应返回了。</p><p>我理解缓存是好的，但是我不得不统计多少人访问了我的网站！<br>如果你必须知道每次页面访问的，选择【一】个页面上的小元素，或者页面本身，通过适当的头信息让其不可缓存，例如： 可以在每个页面上部署一个1x1像素的透明图片。Referer头信息会有包含这个图片的每个页面信息；<br>明确一点：这个并不会给你一个关于你用户精确度很高的统计，而且这对互联网和你的用户这都不太好，消耗了额外的带宽，强迫用户去访问无法缓存的内容。了解更多信息，参考访问统计资料。<br>我如何能看到HTTP头信息的内容？<br>很多浏览器在页面属性或类似界面中可以让你看到Expires 和Last-Modified信息；如果有的话：你会找到页面信息的菜单和页面相关的文件（如图片），并且包含他们的详细信息；<br>看到完整的头信息，你可以用telnet手工连接到Web服务器；<br>为此：你可能需要用一个字段指定端口（缺省是80），或者链接到<a href="http://www.example.com:80" target="_blank" rel="noopener">www.example.com:80</a> 或者 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 80(注意是空格)，更多设置请参考一下telnet客户端的文档；<br>打开网站链接：请求一个查看链接，如果你想看到<a href="http://www.example.com/foo.html" target="_blank" rel="noopener">http://www.example.com/foo.html</a> 连接到<a href="http://www.example.com的80端口后，键入：" target="_blank" rel="noopener">www.example.com的80端口后，键入：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /foo.html HTTP/1.1 [回车]</span><br><span class="line">GET /foo.html HTTP/1.1 [return]</span><br><span class="line">Host: www.example.com [回车][回车]</span><br><span class="line">Host: www.example.com [return][return]</span><br></pre></td></tr></table></figure><p>在[回车]处按键盘的回车键；在最后，要按2次回车，然后，就会输出头信息及完整页面，如果只想看头信息，将GET换成HEAD。</p><h1 id="我的页面是密码保护的，代理缓存服务器如何处理他们？"><a href="#我的页面是密码保护的，代理缓存服务器如何处理他们？" class="headerlink" title="我的页面是密码保护的，代理缓存服务器如何处理他们？"></a>我的页面是密码保护的，代理缓存服务器如何处理他们？</h1><p>缺省的，网页被HTTP认证保护的都是私密内容，它们不会被任何共享缓存保留。但是，你可以通过设置Cache-Control: public让认证页面可缓存，HTTP 1.1标准兼容的缓存服务器会认出它们可缓存。<br>如果你认为这些可缓存的页面，但是需要每个用户认证后才能看，可以组合使用Cache-Control: public和no-cache头信息，高速缓存必须在提供副本之前，将将新客户的认证信息提交给源服务器。设置就是这样：</p><pre><code>Cache-Control: public, no-cache</code></pre><p>无论如何：这是减少认证请求的最好方法，例如： 你的图片是不机密的，将它们部署在另外一个目录，并对此配置服务器不强制认证。这样，那些图片会缺省都缓存。</p><p>我们是否要担心用户通过cache访问我的站点？<br>代理服务器上SSL页面不会被缓存（不推荐被缓存），所以你不必为此担心。但是，由于缓存保存了非SSL请求和从他们抓取的URL，你要意识到没有安全保护的网站，可能被不道德的管理员可能搜集用户隐私，特别是通过URL。<br>实际上，位于服务器和客户端之间的管理员可以搜集这类信息。特别是通过CGI脚本在通过URL传递用户名和密码的时候会有很大问题；这对泄露用户名和密码是一个很大的漏洞；<br>如果你初步懂得互联网的安全机制，你不会对缓存服务器有任何。</p><p>我在寻找一个包含在Web发布系统解决方案，那些是比较有缓存意识的系统？<br>这很难说，一般说来系统越复杂越难缓存。最差就是全动态发布并不提供校验参数；你无发缓存任何内容。可以向系统提供商的技术人员了解一下，并参考后面的实现说明。</p><p>我的图片设置了1个月后过期，但是我现在需要现在更新。<br>过期时间是绕不过去的，除非缓存（浏览器或者代理服务器）空间不足才会删除副本，缓存副本在过期之间会被一直使用。<br>最好的办法是改变它们的链接，这样，新的副本将会从源服务器上重新下载。记住：引用它们的页面本身也会被缓存。因此，使用静态图片和类似内容是很容易缓存的，而引用他们的HTML页面则要保持非常更新；<br>如果你希望对指定的缓存服务器重新载入一个副本，你可以强制使用“刷新”（在FireFox中在reload的时候按住shift键：就会有前面提到恶Pragma: no-cache头信息发出）。或者你可以让缓存的管理员从他们的界面中删除相应内容；<br>我运行一个Web托管服务，如何让我的用户发布缓存友好的网页？<br>如果你使用apahe，可以考虑允许他们使用.htaccess文件并提供相应的文档；<br>另外一方面： 你也可以考虑在各种虚拟主机上建立各种缓存策略。例如： 你可以设置一个目录 /cache-1m 专门用于存放访问1个月的访问，另外一个 /no-cache目录则被用提供不可存储副本的服务。<br>无论如何：对于大量用户访问还是应该用缓存。对于大网站，这方面的节约很明显（带宽和服务器负载）；</p><p>我标记了一些网页是可缓存的，但是浏览器仍然每次发送请求给服务。如何强制他们保存副本？<br>缓存服务器并不会总保存副本并重用副本；他们只是在特定情况下会不保存并使用副本。所有的缓存服务器都回基于文件的大小，类型（例如：图片 页面），或者服务器空间的剩余来确定如何缓存。你的页面相比更热门或者更大的文件相比，并不值得缓存。<br>所以有些缓存服务器允许管理员根据文件类型确定缓存副本的优先级，允许某些副本被永久缓存并长期有效；</p><p>缓存机制的实现 - Web服务器端配置<br>一般说来，应该选择最新版本的Web服务器程序来部署。不仅因为它们包含更多利于缓存的功能，新版本往往在性能和安全性方面都有很多的改善。</p><p>Apache HTTP服务器<br>Apache有些可选的模块来包含这些头信息： 包括Expires和Cache-Control。 这些模块在1.2版本以上都支持；<br>这些模块需要和apache一起编译；虽然他们已经包含在发布版本中，但缺省并没有启用。为了确定相应模块已经被启用：找到httpd程序并运行httpd -l 它会列出可用的模块，我们需要用的模块是mod_expires和mod_headers</p><p>如果这些模块不可用，你需要联系管理员，重新编译并包含这些模块。这些模块有时候通过配置文件中把注释掉的配置启用，或者在编译的时候增加-enable -module=expires和-enable-module=headers选项（在apache 1.3和以上版本）。 参考Apache发布版中的INSTALL文件；<br>Apache一旦启用了相应的模块，你就可以在.htaccess文件或者在服务器的access.conf文件中通过mod_expires设置副本什 么时候过期。你可设置过期从访问时间或文件修改时间开始计算，并且应用到某种文件类型上或缺省设置，参考模块的文档获得更多信息，或者遇到问题的时候向你身边的apache专家讨教。<br>应用Cache-Control头信息，你需要使用mod_headers,它将允许你设置任意的HTTP头信息，参考mod_headers的文档可以获得更多资料；<br>这里有个例子说明如何使用头信息：</p><p>.htaccess文件允许web发布者使用命令只在配置文件中用到的命令。他影响到所在目录及其子目录；问一下你的服务器管理员确认这个功能是否启用了。</p><h3 id="启用-mod-expires"><a href="#启用-mod-expires" class="headerlink" title="启用 mod_expires"></a>启用 mod_expires</h3><p>ExpiresActive On</p><h3 id="设置-gif-在被访问过后1个月过期。"><a href="#设置-gif-在被访问过后1个月过期。" class="headerlink" title="设置 .gif 在被访问过后1个月过期。"></a>设置 .gif 在被访问过后1个月过期。</h3><p>ExpiresByType image/gif A2592000</p><h3 id="其他文件设置为最后修改时间1天后过期"><a href="#其他文件设置为最后修改时间1天后过期" class="headerlink" title="其他文件设置为最后修改时间1天后过期"></a>其他文件设置为最后修改时间1天后过期</h3><h3 id="用了另外的语法"><a href="#用了另外的语法" class="headerlink" title="(用了另外的语法)"></a>(用了另外的语法)</h3><p>ExpiresDefault “modification plus 1 day”</p><h3 id="在index-html文件应用-Cache-Control头属性"><a href="#在index-html文件应用-Cache-Control头属性" class="headerlink" title="在index.html文件应用 Cache-Control头属性"></a>在index.html文件应用 Cache-Control头属性</h3><files index.html>Header append Cache-Control "public, must-revalidate"</files>       注意： 在适当情况下mod_expires会自动计算并插入Cache-Control:max-age 头信息Apache 2.0的配置和1.3类似，更多信息可以参考2.0的mod_expires和mod_headers文档；<h2 id="Microsoft-IIS服务器"><a href="#Microsoft-IIS服务器" class="headerlink" title="Microsoft IIS服务器"></a>Microsoft IIS服务器</h2><p>Microsoft的IIS可以非常容易的设置头信息，注意：这只针对IIS 4.0服务器，并且只能在NT服务器上运行。<br>为网站的一个区域设置头信息，先要到管理员工具界面中，然后设置属性。选择HTTP Header选单，你会看到2个有趣的区域：启用内容过期和定制HTTP头信息。头一个设置会自动配置，第二个可以用于设置Cache-Control头信息；<br>设置asp页面的头信息可以参考后面的ASP章节，也可以通过ISAPI模块设置头信息，细节请参考MSDN。</p><h2 id="Netscape-iPlanet企业服务器"><a href="#Netscape-iPlanet企业服务器" class="headerlink" title="Netscape/iPlanet企业服务器"></a>Netscape/iPlanet企业服务器</h2><p>3.6版本以后，Netscape/iPlanet已经不能设置Expires头信息了，他从3.0版本开始支持HTTP 1.1的功能。这意味着HTTP 1.1的缓存（代理服务器/浏览器）优势都可以通过你对Cache-Control设置来获得。<br>使用Cache-Control头信息，在管理服务器上选择内容管理|缓存设置目录。然后：使用资源选择器，选择你希望设置头信息的目录。设置完头信息后，点击“OK”。更多信息请参考Netscape/iPlanet企业服务器的手册。</p><h1 id="缓存机制的实现：服务器端脚本"><a href="#缓存机制的实现：服务器端脚本" class="headerlink" title="缓存机制的实现：服务器端脚本"></a>缓存机制的实现：服务器端脚本</h1><p>需要注意的一点是：也许服务器设置HTTP头信息比脚本语言更容易，但是两者你都应该使用。<br>因为服务器端的脚本主要是为了动态内容，他本身不产生可缓存的文件页面，即使内容实际是可以缓存的。如果你的内容经常改变，但是不是每次页面请求都改变， 考虑设置一个Cache-Control: max-age头信息；大部分用户会在短时间内多次访问同一页面。例如： 用户点击“后退”按钮，即使没有新内容，他们仍然要再次从服务器下载内容查看。</p><h2 id="CGI程序"><a href="#CGI程序" class="headerlink" title="CGI程序"></a>CGI程序</h2><p>CGI脚本是生成内容最流行的方式之一，你可以很容易在发送内容之前的扩展HTTP头信息；大部分CGI实现都需要你写 Content-Type头信息，例如这个Perl脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/usr/bin/perl</span><br><span class="line">print "Content-type: text/html\n";</span><br><span class="line">print "Expires: Thu, 29 Oct 1998 17:04:19 GMT\n";</span><br><span class="line">print "\n";</span><br><span class="line"><span class="meta">#</span>## 后面是内容体...</span><br></pre></td></tr></table></figure><p>由于都是文本，你可以很容易通过内置函数生成Expires和其他日期相关的头信息。如果你使用<code>Cache-Control: max-age;</code>会更简单；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Cache-Control: max-age=600\n&quot;;</span><br></pre></td></tr></table></figure><p>这样脚本可以在被请求后缓存10分钟；这样用户如果按“后退”按钮，他们不会重新提交请求；<br>CGI的规范同时也允许客户端发送头信息，每个头信息都有一个<code>‘HTTP_’</code>的前缀；这样如果一个客户端发送一个If-Modified-Since请求，就是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP_IF_MODIFIED_SINCE = Fri, 30 Oct 1998 14:19:41 GMT</span><br></pre></td></tr></table></figure><p>参考一下<code>cgi_buffer</code>库，一个自动处理ETag的生成和校验的库，生成Content-Length属性和对内容进行gzip压缩。在Python脚本中也只需加入一行；</p><h2 id="服务器端包含-Server-Side-Includes"><a href="#服务器端包含-Server-Side-Includes" class="headerlink" title="服务器端包含 Server Side Includes"></a>服务器端包含 Server Side Includes</h2><p>SSI（经常使用.shtml扩展名）是网站发布者最早可以生成动态内容的方案。通过在页面中设置特别的标记，也成为一种嵌入HTML的脚本；<br>大部分SSI的实现无法设置校验器，于是无法缓存。但是Apache可以通过对特定文件的组执行权限设置实现允许用户设置那种SSI可以被缓存；结合XbitHack调整整个目录。更多文档请参考mod_include文档。</p><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>PHP是一个内建在web服务器中的服务器端脚本语言，当做为HTML嵌入式脚本，很像SSI，但是有更多的选项，PHP可以在各种Web服务器上设置为CGI模式运行，或者做为Apache的模块；<br>缺省PHP生成副本没有设置校验器，于是也无法缓存，但是开发者可以通过Header()函数来生成HTTP的头信息；<br>例如：以下代码会生成一个Cache-Control头信息，并设置为3天以后过期的Expires头信息；</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> Header(<span class="string">"Cache-Control: must-revalidate"</span>);</span><br><span class="line"></span><br><span class="line"> $offset = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">3</span>;</span><br><span class="line"> $ExpStr = <span class="string">"Expires: "</span> . gmdate(<span class="string">"D, d M Y H:i:s"</span>, time() + $offset) . <span class="string">" GMT"</span>;</span><br><span class="line"> Header($ExpStr);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>记住： Header()的输出必须先于所有其他HTML的输出；<br>正如你看到的：你可以手工创建HTTP日期；PHP没有为你提供专门的函数（新版本已经让这个越来越容易了，请参考PHP的日期相关函数文档），当然，最简单的还是设置Cache-Control: max-age头信息，而且对于大部分情况都比较适用；<br>更多信息，请参考header相关的文档；<br>也请参考一下<code>cgi_buffer</code>库，自动处理ETag的生成和校验，Content-Length生成和内容的gzip压缩，PHP脚本只需包含1行代码；</p><h2 id="Cold-Fusion"><a href="#Cold-Fusion" class="headerlink" title="Cold Fusion"></a>Cold Fusion</h2><p>Cold Fusion是Macromedia的商业服务器端脚本引擎，并且支持多种Windows平台，Linux平台和多种Unix平台。Cold Fusion通过CFHEADER标记设置HTTP头信息相对容易。可惜的是：以下的Expires头信息的设置有些容易误导；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CFHEADER NAME=&quot;Expires&quot; VALUE=&quot;#Now()#&quot;&gt;</span><br></pre></td></tr></table></figure><p>它并不像你想像的那样工作，因为时间（本例中为请求发起的时间）并不会被转换成一个符合HTTP时间，而且打印出副本的Cold fusion的日期/时间对象，大部分客户端会忽略或者将其转换成1970年1月1日。<br>但是：Cold Fusion另外提供了一套日期格式化函数， GetHttpTimeSTring. 结合DateAdd函数，就很容易设置过期时间了，这里我们设置一个Header声明副本在1个月以后过期；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cfheader name=&quot;Expires&quot; value=&quot;#GetHttpTimeString(DateAdd(&apos;m&apos;, 1, Now()))#&quot;&gt;</span><br></pre></td></tr></table></figure><p>你也可以使用CFHEADER标签来设置Cache-Control: max-age等其他头信息；<br>记住：Web服务器也会将头信息设置转给Cold Fusion(做为CGI运行的时候)，检查你的服务器设置并确定你是否可以利用服务器设置代替Cold Fusion。</p><h2 id="ASP和ASP-NET"><a href="#ASP和ASP-NET" class="headerlink" title="ASP和ASP.NET"></a>ASP和ASP.NET</h2><p>在asp中设置HTTP头信息是：确认Response方法先于HTML内容输出前被调用，或者使用 Response.Buffer暂存输出；同样的：注意某些版本的IIS缺省设置会输出Cache-Control: private 头信息，必须声明成public才能被共享缓存服务器缓存。<br>IIS的ASP和其他web服务器都允许你设置HTTP头信息，例如： 设置过期时间，你可以设置Response对象的属性；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% Response.Expires=1440 %&gt;</span><br></pre></td></tr></table></figure><p>设置请求的副本在输出的指定分钟后过期，类似的：也可以设置绝对的过期时间（确认你的HTTP日期格式正确）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% Response.ExpiresAbsolute=#May 31,1996 13:30:15 GMT# %&gt;</span><br></pre></td></tr></table></figure><p>Cache-Control头信息可以这样设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% Response.CacheControl=&quot;public&quot; %&gt;</span><br></pre></td></tr></table></figure><p>在ASP.NET中，Response.Expires 已经不推荐使用了，正确的方法是通过Response.Cache设置Cache相关的头信息；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Response.Cache.SetExpires ( DateTime.Now.AddMinutes ( 60 ) ) ;</span><br><span class="line">Response.Cache.SetCacheability ( HttpCacheability.Public ) ;</span><br></pre></td></tr></table></figure><p>参考MSDN文档可以找到更多相关新年系；</p><h1 id="参考文档和深入阅读"><a href="#参考文档和深入阅读" class="headerlink" title="参考文档和深入阅读"></a>参考文档和深入阅读</h1><p>HTTP 1.1 规范定义<br>HTTP 1.1的规范有大量的扩展用于页面缓存，以及权威的接口实现指南，参考章节：13, 14.9, 14.21, 以及 14.25.</p><p>Web-Caching.com<br>非常精彩的介绍缓存相关概念，并介绍其他在线资源。</p><p>关于非连续性访问统计<br>Jeff Goldberg内容丰富的演说告诉你为什么不应该过度依赖访问统计和计数器；</p><p>可缓存性检测引擎<br>可缓存的引擎设计，检测网页并确定其如何与Web缓存服务器交互， 这个引擎配合这篇指南是一个很好的调试工具，</p><p><code>cgi_buffer</code>库<br>包含库：用于CGI模式运行的Perl/Python/PHP脚本，自动处理ETag生成/校验，Content-Length生成和内容压缩。正确地。 Python版本也被用作其他大量的CGI脚本。</p><h1 id="关于本文档"><a href="#关于本文档" class="headerlink" title="关于本文档"></a>关于本文档</h1><p>本文版权属于Mark Nottingham <a href="mailto:&#109;&#110;&#x6f;&#116;&#64;&#112;&#111;&#x62;&#x6f;&#x78;&#x2e;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#109;&#110;&#x6f;&#116;&#64;&#112;&#111;&#x62;&#x6f;&#x78;&#x2e;&#x63;&#111;&#109;</a>，本作品遵循创作共用版权。<br>如果你镜像本文，请通过以上邮件告知，这样你可以在更新时被通知；<br>所有的商标属于其所有人。<br>虽然作者确信内容在发布时的正确性，但不保证其应用或引申应用的正确性，如有误传，错误或其他需要澄清的问题请尽快告知作者；<br>本文最新版本可以从 <a href="http://www.mnot.net/cache_docs/" target="_blank" rel="noopener">http://www.mnot.net/cache_docs/</a> 获得；<br>翻译版本包括： 捷克语版，法语版和中文版。<br>版本： 1.81 - 2007年3月16日</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面向站长和网站管理员的Web缓存加速指南[翻译]&lt;/p&gt;
&lt;p&gt;原文（英文）地址： &lt;a href=&quot;http://www.mnot.net/cache_docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.mnot.net/ca
      
    
    </summary>
    
    
      <category term="http cache" scheme="http://s.bixuebihui.cn/tags/http-cache/"/>
    
  </entry>
  
  <entry>
    <title>learn yaml in 10 minites</title>
    <link href="http://s.bixuebihui.cn/2019/08/21/learn-yaml-in-10-minites/"/>
    <id>http://s.bixuebihui.cn/2019/08/21/learn-yaml-in-10-minites/</id>
    <published>2019-08-21T10:52:50.000Z</published>
    <updated>2019-08-22T00:55:45.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10分钟之内学会yaml"><a href="#10分钟之内学会yaml" class="headerlink" title="10分钟之内学会yaml"></a>10分钟之内学会yaml</h1><p>YAML是一种数据序列化语言，旨在直接可由人类编写和读取。</p><p>它是JSON的严格超集，重要的是语法上添加了换行符和缩进，类似 Python。但是，与Python不同的是，YAML不允许使用<strong>制表符</strong>进行缩进。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span><span class="bullet">--</span>   <span class="comment"># 文档开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#YAML中的注释看起来像这样的。</span></span><br></pre></td></tr></table></figure><h1 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 我们的根对象（对整个文档而言）将是一个映射，</span></span><br><span class="line"><span class="comment"># 等同于其他语言的字典，散列或对象。</span></span><br><span class="line"><span class="string">key</span> <span class="string">:</span>  <span class="string">value</span> </span><br><span class="line"><span class="string">another_key</span> <span class="string">:</span>  <span class="string">另一个值</span> <span class="string">_在</span> <span class="string">_这里</span></span><br><span class="line"><span class="string">a_number_value</span> <span class="string">:</span>  <span class="number">100</span> </span><br><span class="line"><span class="string">scientific_notation</span> <span class="string">:</span>  <span class="number">1e+12</span> </span><br><span class="line"><span class="comment">#数字1将被解释为数字，而不是布尔值。如果你想</span></span><br><span class="line"><span class="comment">#将它解释为布尔值，请使用true </span></span><br><span class="line"><span class="string">boolean</span> <span class="string">:</span>  <span class="literal">true</span> </span><br><span class="line"><span class="string">null_value</span> <span class="string">:</span>  <span class="literal">null</span> </span><br><span class="line"><span class="string">key</span> <span class="string">with</span> <span class="string">spaces</span> <span class="string">:</span>  <span class="string">value</span> </span><br><span class="line"><span class="comment">#注意字符串不需要引号。但也可以有。</span></span><br><span class="line"><span class="attr">however:</span> <span class="string">'围在引号内的字符串。'</span></span><br><span class="line"><span class="string">'key with spaces'</span> <span class="string">:</span> <span class="string">"带引号的键，如果你想以把一个‘:’ 放键里也是可以的"</span> </span><br><span class="line"><span class="string">single</span> <span class="attr">quotes:</span> <span class="string">'有'</span><span class="string">' 一个'</span><span class="string">' 转义模式'</span> </span><br><span class="line"><span class="string">double</span> <span class="attr">quotes:</span> <span class="string">"有很多:\"，\0，\t，\u263A ，\x0d \x0a == \ r\n，等等"</span>  </span><br><span class="line"><span class="comment">#UTF- 8/16/32个字符需要编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上标2</span></span><br><span class="line"><span class="string">Superscript</span> <span class="attr">two:</span>   <span class="string">\u00B2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#多行字符串可以写成'文字块'（使用|），</span></span><br><span class="line"><span class="comment">#或'折叠块'（使用'&gt;'）。</span></span><br><span class="line"><span class="string">literal_block</span> <span class="string">:</span> <span class="string">| </span></span><br><span class="line"><span class="string">    整个文本块将是'literal_block'键的值，</span></span><br><span class="line"><span class="string">    并保留换行符。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    文字一直持续到反向缩进，并且</span></span><br><span class="line"><span class="string">    删除了前面的缩进。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        任何有“更多缩进”的</span></span><br><span class="line"><span class="string">        行都会保留其余的缩进 - 这些行将缩进4个空</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">folded_style : &gt; </span></span><br><span class="line"><span class="string">    整个文本块将是'folded_style'的值，但这</span></span><br><span class="line"><span class="string">    一次，所有换行都将被替换为单个空格。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    与上面一样，空行将转换为换行符。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        “更多缩进”的行也保留了他们的换行符 - </span></span><br><span class="line"><span class="string">        此文本将显示为两行。</span></span><br></pre></td></tr></table></figure><h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 嵌套使用缩进。优选2个空格缩进（但不是必需的）。</span></span><br><span class="line"><span class="string">a_nested_map</span> <span class="string">:</span></span><br><span class="line">  <span class="string">key</span> <span class="string">:</span>  <span class="string">value</span> </span><br><span class="line">  <span class="string">another_key</span> <span class="string">:</span> <span class="string">Another</span> <span class="string">Value</span> </span><br><span class="line">  <span class="string">another_nested_map</span> <span class="string">:</span></span><br><span class="line">    <span class="string">hello</span> <span class="string">:</span> <span class="string">hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#map不一定有字符串键。</span></span><br><span class="line"><span class="number">0.25</span> <span class="string">:</span>  <span class="string">浮点数键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Key也可能很复杂，比如多行对象</span></span><br><span class="line"><span class="comment">#我们用?后跟一个空格，表示复杂键的开始。</span></span><br><span class="line"><span class="string">?</span> <span class="string">| </span></span><br><span class="line"><span class="string">  这是一个</span></span><br><span class="line"><span class="string">  有多行的键</span></span><br><span class="line"><span class="string">:  这是它的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#YAML还允许使用复杂的键语法在序列之间进行映射</span></span><br><span class="line"><span class="string">#某些语言解析器可能会抱怨</span></span><br><span class="line"><span class="string">#一个例子</span></span><br><span class="line"><span class="string">? -  曼联</span></span><br><span class="line"><span class="string">  -  皇家马德里</span></span><br><span class="line"><span class="string">: [ 2001-01-01 ,  2002-02-02]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Sequence（相当于列表 list 或数组 array）看起来像这样</span></span><br><span class="line"><span class="string">#（注意' - '算作缩进）:</span></span><br><span class="line"><span class="string">a_sequence :</span></span><br><span class="line"><span class="string">  -  Item 1 </span></span><br><span class="line"><span class="string">  -  Item 2 </span></span><br><span class="line"><span class="string">  -  0.5   #sequence可以包含不同的类型。</span></span><br><span class="line"><span class="string">  -  第4项</span></span><br><span class="line"><span class="string">  -  键: 值</span></span><br><span class="line"><span class="string">    another_key : another_value </span></span><br><span class="line"><span class="string">  - </span></span><br><span class="line"><span class="string">    -  这是一个序列</span></span><br><span class="line"><span class="string">    -  在另一个序列中</span></span><br><span class="line"><span class="string">  -  -  -  嵌套序列指示符</span></span><br><span class="line"><span class="string">         -  可以折叠</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#由于YAML是JSON的超集，则也可以编写JSON式map和</span></span><br><span class="line"><span class="string">#序列:</span></span><br><span class="line"><span class="string">json_map : &#123; "钥匙" : "值" &#125; </span></span><br><span class="line"><span class="string">json_seq : [ 3 , 2, 1 , "起飞" ] </span></span><br><span class="line"><span class="string">and quotes are optional: &#123; 键: [ 3 , 2 , 1 , 起飞]&#125;  #且引号是可选的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```yaml </span></span><br><span class="line"><span class="string">#          YAML 附加特性              #</span></span><br><span class="line"><span class="string">```yaml</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#YAML还有一个名为“anchors”的便捷功能，可让您轻松复制文档中的</span></span><br><span class="line"><span class="string"># 内容。这两个按键也会有同样的值:</span></span><br><span class="line"><span class="string">anchored_content : &amp;anchor_name  此字符串将显示为两个键的值。</span></span><br><span class="line"><span class="string">other_anchor :  *anchor_name</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Anchors 可用于复制/继承属性</span></span><br><span class="line"><span class="string">base :  &amp;base </span></span><br><span class="line"><span class="string">  name :  大家都有相同的名字</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># regexp &lt;&lt; 被称为语言无关的合并键类型 。它用于</span></span><br><span class="line"><span class="string">#表示应将一个或多个指定映射的所有键插入到当前映射中。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">foo : &amp;foo </span></span><br><span class="line"><span class="string">  &lt;&lt; : *base</span></span><br><span class="line"><span class="string"></span><span class="attr">  age:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="string">bar</span> <span class="string">:</span> <span class="meta">&amp;bar</span> </span><br><span class="line">  <span class="string">&lt;&lt;</span> <span class="string">:</span> <span class="meta">*base</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#foo和bar也有name: ‘大家都有相同的名字’</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#YAML还有标记，您可以使用它来显式声明类型。</span></span><br><span class="line"><span class="string">explicit_string</span> <span class="string">:</span> <span class="type">!!str</span>  <span class="number">0.5</span> </span><br><span class="line"><span class="comment">#一些解析器实现了特定于语言的标签，就像Python的</span></span><br><span class="line"><span class="comment"># 复数 complex 数字类型一样。</span></span><br><span class="line"><span class="string">python_complex_number</span> <span class="string">:</span> <span class="type">!!python</span><span class="string">/complex</span>  <span class="number">1</span> <span class="string">+</span> <span class="number">2</span><span class="string">j</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#我们还可以使用带语言特定标签的yaml复合键</span></span><br><span class="line"><span class="string">?</span> <span class="type">!!python</span><span class="string">/tuple</span> <span class="string">[5,</span> <span class="number">7</span><span class="string">]</span></span><br><span class="line"><span class="string">:</span> <span class="string">Fifty</span> <span class="string">Seven</span></span><br><span class="line"><span class="comment">#在Python将是 &#123;(5, 7): 'Fifty Seven'&#125;</span></span><br></pre></td></tr></table></figure><h1 id="更多-YAML-类型"><a href="#更多-YAML-类型" class="headerlink" title="更多 YAML 类型"></a>更多 YAML 类型</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#字符串和数字不是YAML可以理解的唯一标量。</span></span><br><span class="line"><span class="comment">#ISO格式的日期和日期时间也被解析。</span></span><br><span class="line"><span class="string">datetime</span> <span class="string">:</span> <span class="number">2001</span><span class="bullet">-12</span><span class="bullet">-15</span><span class="attr">T02:59:43.1Z</span> </span><br><span class="line"><span class="string">datetime_with_spaces</span> <span class="string">:</span> <span class="number">2001</span><span class="bullet">-12</span><span class="bullet">-14</span> <span class="number">21</span><span class="string">:59:43.10</span> <span class="bullet">-5</span> </span><br><span class="line"><span class="string">date</span> <span class="string">:</span> <span class="number">2002</span><span class="bullet">-12</span><span class="bullet">-14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!!binary 标签表示字符串实际上是二进制的base64编码的大字段 blob</span></span><br><span class="line"><span class="comment"># 浏览器地址栏粘上以下内容去看看吧：</span></span><br><span class="line"><span class="comment"># data:image/git;base64,R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5 OTk6enp56enmlpaWNjY6Ojo4SEhP/++f/++f/++f/++f/++f/++f/++f/++f/+ +f/++f/++f/++f/++f/++SH+Dk1hZGUgd2l0aCBHSU1QACwAAAAADAAMAAAFLC AgjoEwnuNAFOhpEMTRiggcz4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs=</span></span><br><span class="line"><span class="string">gif_file</span> <span class="string">:</span> <span class="type">!!binary</span> <span class="string">|</span></span><br><span class="line"><span class="string">  R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5</span></span><br><span class="line"><span class="string">  OTk6enp56enmlpaWNjY6Ojo4SEhP/++f/++f/++f/++f/++f/++f/++f/++f/+</span></span><br><span class="line"><span class="string">  +f/++f/++f/++f/++f/++SH+Dk1hZGUgd2l0aCBHSU1QACwAAAAADAAMAAAFLC</span></span><br><span class="line"><span class="string">  AgjoEwnuNAFOhpEMTRiggcz4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs=</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#YAML也有集合 set 类型，它看起来像这样:</span></span><br><span class="line"><span class="string"></span><span class="attr">set:</span></span><br><span class="line">  <span class="string">?</span> <span class="string">item1</span> </span><br><span class="line">  <span class="string">?</span> <span class="string">item2</span> </span><br><span class="line">  <span class="string">?</span> <span class="string">item3</span> </span><br><span class="line"><span class="attr">or:</span> <span class="string">&#123;</span> <span class="string">item1</span> <span class="string">,</span> <span class="string">item2</span> <span class="string">,</span> <span class="string">item3</span> <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#集 set 只是具有空值的映射map; 以上等同于:</span></span><br><span class="line"><span class="string">set2</span> <span class="string">:</span></span><br><span class="line">  <span class="string">item1</span> <span class="string">:</span> <span class="literal">null</span> </span><br><span class="line">  <span class="string">item2</span> <span class="string">:</span> <span class="literal">null</span> </span><br><span class="line">  <span class="string">item3</span> <span class="string">:</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span>   <span class="comment">#全文完</span></span><br></pre></td></tr></table></figure><p><a href="downloads/code/learnyaml.yaml">下载源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;10分钟之内学会yaml&quot;&gt;&lt;a href=&quot;#10分钟之内学会yaml&quot; class=&quot;headerlink&quot; title=&quot;10分钟之内学会yaml&quot;&gt;&lt;/a&gt;10分钟之内学会yaml&lt;/h1&gt;&lt;p&gt;YAML是一种数据序列化语言，旨在直接可由人类编写和读取。&lt;
      
    
    </summary>
    
    
      <category term="yaml" scheme="http://s.bixuebihui.cn/tags/yaml/"/>
    
  </entry>
  
  <entry>
    <title>函数原型中的 call 和 apply 方法的区别</title>
    <link href="http://s.bixuebihui.cn/2019/08/20/js-call-vs-apply/"/>
    <id>http://s.bixuebihui.cn/2019/08/20/js-call-vs-apply/</id>
    <published>2019-08-20T15:06:52.000Z</published>
    <updated>2019-08-21T12:52:39.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="call-apply都属于Function-prototype的方法"><a href="#call-apply都属于Function-prototype的方法" class="headerlink" title="call, apply都属于Function.prototype的方法"></a>call, apply都属于Function.prototype的方法</h1><p>它们是在 JavaScript 引擎内在实现的，因为属于Function.prototype，所以每个Function对象实例，也就是每个方法都有call, apply属性。它们的作用一样，只是使用方式不同。</p><h1 id="call-与-apply-调用参数不同"><a href="#call-与-apply-调用参数不同" class="headerlink" title="call 与 apply 调用参数不同"></a>call 与 apply 调用参数不同</h1><p>不同之处在于调用apply函数时，参数可以使用数组; <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">call</a>要求明确列出参数。</p><blockquote><p><strong>助记法</strong>: <strong>A</strong>pply 的A表示 Array, 即数组, 而 <strong>C</strong>all 的 C 表示 Comma, 即逗号。</p></blockquote><p>更多请参阅<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">MDN</a>的文档。</p><p>伪语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">theFunction.apply(valueForThis, arrayOfArgs)</span><br><span class="line">theFunction.call(valueForThis, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><p>从ES6开始，还有<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="noopener">展开spread</a>数组与该call功能一起使用的可能性，你可以在<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">这里</a>看到兼容性。</p><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">theFunction</span>(<span class="params">name, profession</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"My name is "</span> + name + <span class="string">" and I am a "</span> + profession +<span class="string">"."</span>);</span><br><span class="line">&#125;</span><br><span class="line">theFunction(<span class="string">"John"</span>, <span class="string">"fireman"</span>);</span><br><span class="line">theFunction.apply(<span class="literal">undefined</span>, [<span class="string">"Susan"</span>, <span class="string">"school teacher"</span>]);</span><br><span class="line">theFunction.call(<span class="literal">undefined</span>, <span class="string">"Claude"</span>, <span class="string">"mathematician"</span>);</span><br><span class="line">theFunction.call(<span class="literal">undefined</span>, ...[<span class="string">"Matthew"</span>, <span class="string">"physicist"</span>]); <span class="comment">// 使用展开语法</span></span><br></pre></td></tr></table></figure><h1 id="搞这么复杂，直接调用函数不好吗？"><a href="#搞这么复杂，直接调用函数不好吗？" class="headerlink" title="搞这么复杂，直接调用函数不好吗？"></a>搞这么复杂，直接调用函数不好吗？</h1><p>主要是为了模拟面向对象，对状态进行封装的同时， 不同实例可以有不同的内部状态，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">42</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> unboundGetX = <span class="built_in">module</span>.getX;</span><br><span class="line"><span class="built_in">console</span>.log(unboundGetX()); <span class="comment">// 函数在全局范围内调用，this=window</span></span><br><span class="line"><span class="comment">// 会输出: undefined， 因为window下没有定义x</span></span><br><span class="line">unboundGetX.call(<span class="built_in">module</span>) <span class="comment">//输出 42, 或使用 bind 也有同样的效果</span></span><br><span class="line"><span class="keyword">var</span> module1 =&#123;</span><br><span class="line">   x:<span class="number">123</span>,</span><br><span class="line">   getX: unboundGetX  <span class="comment">//this 变为module1</span></span><br><span class="line">&#125;</span><br><span class="line">module1.getX() <span class="comment">//返回123</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;call-apply都属于Function-prototype的方法&quot;&gt;&lt;a href=&quot;#call-apply都属于Function-prototype的方法&quot; class=&quot;headerlink&quot; title=&quot;call, apply都属于Function.p
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://s.bixuebihui.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 Stream for Parallel &amp; Async</title>
    <link href="http://s.bixuebihui.cn/2019/08/13/Java-8-Stream-for-Parallel-Async/"/>
    <id>http://s.bixuebihui.cn/2019/08/13/Java-8-Stream-for-Parallel-Async/</id>
    <published>2019-08-13T15:48:03.000Z</published>
    <updated>2019-08-21T12:52:59.845Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8中的并行和异步编程<br>2018年4月17日</p><p>Lisa Steendam<br>软件工程师</p><p>并行编程不再需要成为寻找更快代码的难以逾越的障碍。<br>并行代码是在多个线程上运行的代码，曾经是许多经验丰富的开发人员的噩梦，但是Java 8带来了许多变化，这些变化应该会使这种提升性能的技巧更易于管理。</p><h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><p>在Java 8之前，并行（或并发）代码和顺序代码之间存在很大差异。调试非顺序代码也非常困难。简单地设置断点并像通常那样通过流程，将删除并行方面，如果这是导致错误的原因，这是一个问题。</p><p>幸运的是，Java 8为我们提供了流，这是自Java开发以来Java开发人员最棒的事情。如果您不知道它们是什么，Stream API可以处理功能问题中的元素序列。（在这里检查我们在流和.NET的LINQ之间的比较。）流的一个优点是代码的结构保持不变：无论是顺序的还是并发的，它都保持可读性。</p><p>要使代码并行运行，只需使用.parallelStream()而不是.stream()（或者stream.parallel()，如果您不是流的创建者）。</p><p>但仅仅因为它很容易，并不意味着并行代码始终是最佳选择。您应该始终考虑对您的代码使用并发性是否有任何意义。决定中最重要的因素是速度：如果它使代码比顺序代码更快，则只使用并发。</p><h2 id="速度问题"><a href="#速度问题" class="headerlink" title="速度问题"></a>速度问题</h2><p>并行代码通过使用多个线程而不是顺序代码使用的单个线程获得速度。确定要创建多少线程可能是一个棘手的问题，因为更多的线程并不总是导致更快的代码：如果使用太多线程，代码的性能可能实际上会下降。</p><p>有几条规则可以告诉您选择的线程数。这主要取决于您要执行的操作类型和可用内核数。</p><p>计算密集型操作应使用低于或等于内核数量的多个线程，而复制文件等IO密集型操作对CPU没有用处，因此可以使用更多数量的线程。除非您告诉它该做什么，否则代码不知道哪种情况适用。否则，它将默认为多个线程数等于核心数。</p><p>有两种主要情况可能有助于运行代码并行而不是顺序：耗时的任务和任务在大型集合上运行。Java 8带来了处理这些大型集合的新方法，即使用流。流通过懒惰具有内置效率：它们使用惰性评估，通过不做必要的操作来节省资源。这与并行性不同，并行性只要它变得更快就不关心资源。因此，对于大型集合，您可能不需要经典的并行性。</p><p>================================================== ====================</p><h2 id="去异步"><a href="#去异步" class="headerlink" title="去异步"></a>去异步</h2><p>JavaScript的经验教训<br>很少见，Java开发人员可以说他们从查看JavaScript中学到了一些东西，但是当谈到异步编程时，JavaScript实际上是先做对了。作为一种基本的异步语言，JavaScript在糟糕实现时会有多么痛苦的经验。它始于回调，后来被承诺取代。承诺的一个重要好处是它有两个“通道”：一个用于数据，一个用于错误。JavaScript承诺可能如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func</span><br><span class="line">.then(f1)</span><br><span class="line">.catch(e1)</span><br><span class="line">.then(f2)</span><br><span class="line">.catch(e2);</span><br></pre></td></tr></table></figure><p>因此，当原始函数具有成功结果时，将调用f1，但如果抛出错误，则将调用e1。这可能会将其带回成功的轨道（f2），或导致另一个错误（e2）。您可以从数据轨道转到错误轨道并返回。</p><p>JavaScript版本的Java承诺称为CompletableFuture。</p><p>CompletableFuture<br>CompletableFuture实现Future和CompletionStage接口。Future已经存在于Java8之前，但它本身并不是非常开发人员友好的。您只能通过使用该.get()方法获取异步计算的结果，该方法阻止了其余部分（使异步部分在大多数情况下非常无意义）并且您需要手动实现每个可能的方案。添加CompletionStage界面是使Java中的异步编程可行的突破。</p><p>CompletionStage是一种承诺，即最终将完成计算的承诺。它包含一系列方法，可以附加将在完成时执行的回调。现在我们可以不受阻塞地处理结果。</p><p>有两种主要的方法可以让你启动代码的异步部分：supplyAsync如果你想对方法的结果做一些事情，runAsync如果你不想。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() → System.out.println(&quot;Run async in completable future &quot; + Thread.currentThread()));</span><br><span class="line">CompletableFuture.supplyAsync(() → 5);</span><br></pre></td></tr></table></figure><p> 回调</p><p>现在，您可以添加这些回调来处理supplyAsync的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() → 5)</span><br><span class="line">.thenApply(i → i * 3)</span><br><span class="line">.thenAccept(i → System.out.println(“The result is “ + i)</span><br><span class="line">.thenRun(() → System.out.println(&quot;Finished.&quot;));</span><br></pre></td></tr></table></figure><p>.thenApply类似于.map流的功能：它执行转换。在上面的例子中，它取结果（5）并将其乘以3.然后将结果（15）传递到管道下方。</p><p>.thenAccept对结果执行方法而不转换它。它也不会返回结果。在这里它将打印“结果为15”到控制台。它可以与.foreach流的方法进行比较。</p><p>.thenRun不使用异步操作的结果并且也不返回任何内容，它只是等待调用它Runnable直到上一步完成。</p><h2 id="异步你的异步"><a href="#异步你的异步" class="headerlink" title="异步你的异步"></a>异步你的异步</h2><p>以上所有的回调方法也都在异步版本：thenRunAsync，thenApplyAsync等等。这些版本都可以在自己的线程运行，他们给你额外的控制，因为你可以告诉它ForkJoinPool使用。</p><p>如果不使用异步版本，则回调将全部在同一个线程上执行。</p><h2 id="当事情出错时"><a href="#当事情出错时" class="headerlink" title="当事情出错时"></a>当事情出错时</h2><p>当出现问题时，该exceptionally方法用于处理异常。您可以为其提供一个方法，该方法返回一个值以返回数据轨道，或抛出（新）异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.exceptionally(ex → new Foo())</span><br><span class="line">.thenAccept(this::bar);</span><br></pre></td></tr></table></figure><h2 id="结合和撰写"><a href="#结合和撰写" class="headerlink" title="结合和撰写"></a>结合和撰写</h2><p>您可以CompletableFutures使用该thenCompose方法链接多个。没有它，结果将是嵌套的CompletableFutures。这使得thenCompose和thenApply喜欢flatMap和map流。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;)</span><br><span class="line">.thenCompose(s -&gt; CompletableFuture</span><br><span class="line">.supplyAsync(() -&gt; s + &quot;World&quot;));</span><br></pre></td></tr></table></figure><p>如果要组合两个结果CompletableFutures，则需要一个方便调用的方法thenCombine。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">future.thenCombine(future2, Integer::sum)</span><br><span class="line">.thenAccept(value →  System.out.println(value));</span><br></pre></td></tr></table></figure><p>正如您在上面的示例中所看到的，回调的结果thenCombine可以像CompletableFuture所有您喜欢的CompletionStage方法一样处理。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>并行编程不再需要成为寻找更快代码的难以逾越的障碍。Java 8使得该过程尽可能简单，因此任何可能从中受益的代码都可以在所有线程上被拉，踢和尖叫，进入多核未来，实际上就是现在天。我的意思是：它很容易做到，所以试一试，看看它对你自己有什么好处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 8中的并行和异步编程&lt;br&gt;2018年4月17日&lt;/p&gt;
&lt;p&gt;Lisa Steendam&lt;br&gt;软件工程师&lt;/p&gt;
&lt;p&gt;并行编程不再需要成为寻找更快代码的难以逾越的障碍。&lt;br&gt;并行代码是在多个线程上运行的代码，曾经是许多经验丰富的开发人员的噩梦，但是Java
      
    
    </summary>
    
    
      <category term="java" scheme="http://s.bixuebihui.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Energy–maneuverability theory</title>
    <link href="http://s.bixuebihui.cn/2019/08/13/Energy%E2%80%93maneuverability-theory/"/>
    <id>http://s.bixuebihui.cn/2019/08/13/Energy–maneuverability-theory/</id>
    <published>2019-08-13T03:31:57.000Z</published>
    <updated>2019-08-13T16:06:11.986Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Energy_Maneuverability_diagram.jpg/300px-Energy_Maneuverability_diagram.jpg" alt="em"></p><p>能量可操作性理论是飞机性能的模型。它由战斗机飞行员John Boyd上校和空军数学家Thomas P. Christie [1]开发，可用于描述飞机的动力和潜在能量或飞机比能量的总和。它将飞机的推力，重量，气动阻力，机翼面积和其他飞行特性与定量模型联系起来。这允许预测和比较各种飞机的战斗能力或预期的设计权衡。</p><p>飞机性能的所有这些方面都通过以下公式压缩为单个值：</p><p>PS = V (T − D)/ W<br>V = Speed<br>T = Thrust<br>D = Drag<br>W = Weight</p><p>$$\frac{\partial u}{\partial t}<br>= h^2 \left( \frac{\partial^2 u}{\partial x^2} +<br>\frac{\partial^2 u}{\partial y^2} +<br>\frac{\partial^2 u}{\partial z^2}\right)$$</p><p>Simple inline $a = b + c$.</p><p>$${\displaystyle {\begin{array}{rcl}P_{S}&amp;=&amp;V\left({\frac {T-D}{W}}\right)\\V&amp;=&amp;{\text{Speed}}\T&amp;=&amp;{\text{Thrust}}\D&amp;=&amp;{\text{Drag}}\W&amp;=&amp;{\text{Weight}}\end{array}}} {\displaystyle {\begin{array}{rcl}P_{S}&amp;=&amp;V\left({\frac {T-D}{W}}\right)\\V&amp;=&amp;{\text{Speed}}\T&amp;=&amp;{\text{Thrust}}\D&amp;=&amp;{\text{Drag}}\W&amp;=&amp;{\text{Weight}}\end{array}}}$$</p><p>换言之，特定的过剩能量与净动力的比率与平面的重量成比例并且与速度成比例。（注意，在尺寸上，PS {\ displaystyle P_ {S}} P_S具有“速度”的单位，而不是“特定能量”（每单位质量的能量）。）</p><p>通过计算发动机在考虑到减缓飞机的摩擦和其他空气动力学问题后移动飞机的能力，可以找到净动力。比率（TD）/ W类似于T / W，即推力重量比，其也用作飞机和火箭的品质因数。通过将动力归一化到平面的重量，很明显平面的效率如何。一个非常大的发动机可能会产生巨大的推力，但可能会很重，甚至不会抬起自己。当发动机足够强大以使飞机在90度上升轨迹中保持恒定速度时，该比率为单位（TD）/ W = 1。F-16等战斗机的T / W比率接近1，具体取决于燃油重量和武器装备。</p><p>T / W和（TD）/ W之间的差异是T / W不包括摩擦和其他空气动力学损失的影响。当飞机移动非常缓慢时，这些损失很小，可以忽略不计。但是，T / W并未准确描述飞机在正常运行条件下的性能。通过在公式中包含阻力，平面的空气动力学也总结在PS {\ displaystyle P_ {S}} P_S值中。</p><p>SEE [需要澄清]模型与飞机的速度成比例。这意味着飞机能够飞得越快，得分就越高。这个模型的其他部分（推力，阻力和重量）可能会说飞机非常出色，但是一个好的战斗机也必须快速行驶。</p><p>朝鲜战争中的美国喷气式战斗机飞行员博伊德在20世纪60年代初开始研究该理论。他与埃格林空军基地的数学家托马斯克里斯蒂合作，利用基地的高速计算机来比较韩国和越南战争中美国和苏联飞机的性能范围。他们在1964年完成了关于他们研究的两卷报告。能量机动性在美国空军中得到了接受，并使F-15 Eagle和后来的F-16 Fighting Falcon战斗机的要求有所改善。[2]<br>笔记</p><p>纽菲尔德，雅各布; Watson，George M.（Jr。）; Chenoweth，David，编辑。（1997年），技术和空军：回顾性评估（PDF），空军历史和博物馆计划，美国空军，p。204</p><p>Jenkins, Dennis R. McDonnell Douglas F-15 Eagle, Supreme Heavy-Weight Fighter, p.7. Aerofax, 1998.<br>参考</p><p>Hammond, Grant T. The Mind of War: John Boyd and American Security. Washington, D.C.: Smithsonian Institution Press, 2001. ISBN 1-56098-941-6 and ISBN 1-58834-178-X. Coram, Robert. Boyd: The Fighter Pilot Who Changed the Art of War. New York: Back Bay Books, 2002. ISBN 0-316-88146-5 and ISBN 0-316-79688-3. Wendl, M.J., G.G. Grose, J.L. Porter, and V.R. Pruitt. Flight/Propulsion Control Integration Aspects of Energy Management. Society of Automotive Engineers, 1974, p. 740480.</p><p>Energy–maneuverability theory is a model of aircraft performance. It was developed by Col. John Boyd, a fighter pilot, and Thomas P. Christie a mathematician with the Air Force,[1] and is useful in describing an aircraft’s performance as the total of kinetic and potential energies or aircraft specific energy. It relates the thrust, weight, aerodynamic drag, wing area, and other flight characteristics of an aircraft into a quantitative model. This allows combat capabilities of various aircraft or prospective design trade-offs to be predicted and compared.</p><p>All of these aspects of airplane performance are compressed into a single value by the following formula:</p><pre><code>P S = V ( T − D W ) V = Speed T = Thrust D = Drag W = Weight {\displaystyle {\begin{array}{rcl}P_{S}&amp;=&amp;V\left({\frac {T-D}{W}}\right)\\\\V&amp;=&amp;{\text{Speed}}\\T&amp;=&amp;{\text{Thrust}}\\D&amp;=&amp;{\text{Drag}}\\W&amp;=&amp;{\text{Weight}}\end{array}}} {\displaystyle {\begin{array}{rcl}P_{S}&amp;=&amp;V\left({\frac {T-D}{W}}\right)\\\\V&amp;=&amp;{\text{Speed}}\\T&amp;=&amp;{\text{Thrust}}\\D&amp;=&amp;{\text{Drag}}\\W&amp;=&amp;{\text{Weight}}\end{array}}}</code></pre><p>In words, the specific excess energy is proportional to the ratio of net motive forces compared to the weight of the plane and proportional to speed. (Note that dimensionally, P S {\displaystyle P_{S}} P_S has units of “speed,” not “specific energy” (energy per unit mass).)</p><p>The net motive force is found by calculating the engine’s ability to move the plane after accounting for friction and other aerodynamic issues that slow down the plane. The ratio (T-D)/W is similar to T/W, the Thrust-to-weight ratio, which is also used as a figure of merit for airplanes and rockets. By normalizing the motive forces to the weight of the plane, it is clear how efficient the plane is. A very large engine may be able to generate a huge thrust but could be so heavy that it would not even lift itself. The ratio is unity (T-D)/W = 1 when the engine is powerful enough to keep the plane at constant speed in a 90 degree ascending trajectory. Fighter jets, such as the F-16 have a T/W ratio close to 1, depending on fuel weight and armament.</p><p>The difference between T/W and (T-D)/W is that T/W does not include the effects of friction and other aerodynamic losses. When a plane is moving very slowly, these losses are small and can be ignored. However, T/W does not accurately describe the performance of the plane at its normal operating conditions. By including drag in the formula, the aerodynamics of the plane are also summarized in the P S {\displaystyle P_{S}} P_S value.</p><p>The SEE[clarification needed] model is proportional to the speed of the plane. This means that the faster the plane is capable of flying, the better its score. The other parts of this model (thrust, drag, and weight) may say that a plane is excellent but a good fighter must also go fast.</p><p>Boyd, a U.S. jet fighter pilot in the Korean War, began developing the theory in the early 1960s. He teamed with mathematician Thomas Christie at Eglin Air Force Base to use the base’s high-speed computer to compare the performance envelopes of U.S. and Soviet aircraft from the Korean and Vietnam Wars. They completed a two-volume report on their studies in 1964. Energy Maneuverability came to be accepted within the U.S. Air Force and brought about improvements in the requirements for the F-15 Eagle and later the F-16 Fighting Falcon fighters.[2]<br>Notes</p><p>Neufeld, Jacob; Watson, George M. (Jr.); Chenoweth, David, eds. (1997), Technology and the Air Force: A Retrospective Assessment (PDF), Air Force History and Museums Program, United States Air Force, p. 204</p><pre><code>Jenkins, Dennis R. McDonnell Douglas F-15 Eagle, Supreme Heavy-Weight Fighter, p.7. Aerofax, 1998.</code></pre><p>References</p><pre><code>Hammond, Grant T. The Mind of War: John Boyd and American Security. Washington, D.C.: Smithsonian Institution Press, 2001. ISBN 1-56098-941-6 and ISBN 1-58834-178-X.Coram, Robert. Boyd: The Fighter Pilot Who Changed the Art of War. New York: Back Bay Books, 2002. ISBN 0-316-88146-5 and ISBN 0-316-79688-3.Wendl, M.J., G.G. Grose, J.L. Porter, and V.R. Pruitt. Flight/Propulsion Control Integration Aspects of Energy Management. Society of Automotive Engineers, 1974, p. 740480.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Energy_Maneuverability_diagram.jpg/300px-Energy_Maneuverability_diagr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>to be or to do</title>
    <link href="http://s.bixuebihui.cn/2019/08/13/to-be-or-to-do/"/>
    <id>http://s.bixuebihui.cn/2019/08/13/to-be-or-to-do/</id>
    <published>2019-08-13T03:26:47.000Z</published>
    <updated>2019-08-13T15:02:16.844Z</updated>
    
    <content type="html"><![CDATA[<p>在： 男人的生活，行动，领导，在男子气概中的教训</p><p>Brett＆Kate McKay • 2014年1月22日 最后更新时间： 2018年12月7日</p><h1 id="约翰博伊德的唱名表：你想成为某人还是做点什么？"><a href="#约翰博伊德的唱名表：你想成为某人还是做点什么？" class="headerlink" title="约翰博伊德的唱名表：你想成为某人还是做点什么？"></a>约翰博伊德的唱名表：你想成为某人还是做点什么？</h1><p>约翰博伊德战斗机飞行员空军战略家 </p><p>根据他的传记作者罗伯特·科拉姆（Robert Coram）的说法，约翰·博伊德（John Boyd）对战斗机战术，飞机设计和空战理论的贡献超过了空军历史上的任何人。</p><p>作为一名战斗机飞行员，他不败并赢得了绰号“40-Second Boyd”，因为他能够在一分钟内赢得任何混战。</p><p>在驾驶舱中无与伦比，他的思想也没有竞争对手。他不仅仅是一个战斗的战士，而是一个战士工程师和战士 - 哲学家。</p><p>当他33岁时，他写了“空中攻击研究”，这首次编写了最佳的狗斗战术，成为了“空战圣经”，并彻底改变了世界上每一支空军的方法。</p><p>他的能量可操作性（EM）理论帮助生产了具有传奇色彩的F-15，F-16和A-10飞机。</p><p>他开发的一个简报，“冲突模式”，改变了空军和地面部队的作战策略，引入了经常引用的，通常被误解的OODA循环，“使他成为自孙子写”战争艺术“以来最具影响力的军事思想家2，400年前。“</p><p>总而言之，约翰博伊德在美国空军服役了二十四年并经历了三次战争。</p><p>但他从来没有晋升过上校。</p><p>所有这些都是因为博伊德顽固地拒绝妥协他的原则和进步的理想。</p><h2 id="一把叉子在路上"><a href="#一把叉子在路上" class="headerlink" title="一把叉子在路上"></a>一把叉子在路上</h2><p>尽管博伊德在年轻时就加入了军队 - 在第二次世界大战期间作为一名大三学生从高中辍学加入陆军航空兵团 - 但他从来不适合美国的战斗部队。</p><p>并不是说他没有战斗策略和方法的头脑。恰恰相反。当他获得翅膀时，他的飞行员们认为他是一个“好棍子”，他们不断向他寻求关于如何改进的提示和想法。因此，他开始撰写非正式简报，绘制有关处理技巧和空对空技术的图表，并为感兴趣的人举办临时课程。这导致在拉斯维加斯郊外的内利斯空军基地的高级精英战斗机武器学校担任讲师和学术主任。在那里，他着手彻底改革策略课程。空中战术以前是从飞行员到飞行员的一种艺术; 博伊德开始着手开发和编纂最好的技术 - 将斗狗变成一门科学。</p><p>然而，博伊德并不适合这个机构。他不是那些只是因为订单而遵守订单的经典士兵。预计一名军官将受到良好的纪律处分，对上级表示恭敬，并且是现状的捍卫者。博伊德没有这些东西。自第一次世界大战以来，空中战术并未发生太大变化，但并非所有人都乐于看到他们受到挑战 - 他们喜欢按照他们一直以来的方式做事。但博伊德知道自己是对的时候不会退缩。</p><p>他的信念和他的对抗风格的强度为他赢得了绰号“The Mad Major”和“Genghis John。”Boyd不断地对完全不服从的边缘调情，他知道这一点。他喜欢说，“ 你必须挑战所有的假设。如果你不这样做，那么第一天的教义就会永远成为教条。“</p><p>博伊德的光彩与傲慢的结合使他成为一个真正的两极分化。在他的表现评论中，他的一些上司批评他的举止和缺乏尊重，而其他人称他为他们所知道的最有才华和最敬业的官员。前者试图破坏他的职业生涯，而后者则努力让他留在队伍中，而博伊德起初确信他的支持者会赢得这一天。</p><p>因此，当他因为一些无关紧要但又合规的纸张推动者而获得晋升而被传递时，Coram写道，Boyd受到这种打击“深受影响”：</p><p>“这是他职业生涯中的关键事件，也是个人的顿悟。通常，当一个男人年轻且理想主义时，他相信如果他努力工作并做正确的事，那么成功就会随之而来。这就是博伊德的母亲和儿时导师告诉他的。但是，在军队中，努力工作和成功并不总是在一起，成功是由军衔定义的，而达到更高的级别需要符合军方的价值体系。那些不顺从的人终有一天会意识到做正确事情的道路已经偏离了成功的道路，然后他们必须决定他们将在生活中遵循哪条道路。几乎可以肯定的是，他意识到，如果他在完成所有这些工作之后没有提前晋升为中校，他将永远不会获得高级别。“</p><p>当许多官员意识到他们无法达到层级的顶层时，他们会辞职。但博伊德没有加入军队，在他的制服上积累徽章; 他被“改变人们对航空的基本认识”的愿望所驱使，并真诚希望为战争和世界作出重大而持久的贡献。空军是一个非常不完美的渠道，但这是最好的。他明白，改变一个机构的最佳方式往往不是从外面辍学和反对它，而是留在并努力从内部改变它。他的工作远未完成。</p><h2 id="成为或做"><a href="#成为或做" class="headerlink" title="成为或做"></a>成为或做</h2><p>在内利斯之后，博伊德被分配到五角大楼，这种气氛更不适合他的气质。正如科拉姆所指出的那样，这是一个野心家的地方 - 他们被称为蓝色套房。在“建筑物”内部取得进展涉及相同剂量的对接和背刺和成功，如果通常以赢得一个人自己的服务分支的最大金额来衡量。一个错误的举动可能会破坏你的职业生涯。</p><p>不过，博伊德并没有卖掉他的灵魂。他并没有被这样一个事实所吓倒：作为一名39岁的少校，该建筑物中的其他人的等级更高，而且牙齿更长。</p><p>他不知疲倦地工作以改进军方的飞机，特别讨厌他的上司的空白检查态度，这些态度往往伴随着对飞机的设计和效率缺乏理性思维。因为博伊德真诚地相信他为美国纳税人工作，他不仅喜欢把蠢货放在臃肿的预算上，而且还非常喜欢它。他非常喜欢挑选欺骗性的数据和“软管”将军，朋友会在他的生日那天买他的花园软管作为插科打的礼物。他曾经在一个将军的领带上烧了一个洞，在他走投无路并开始用点燃的雪茄戳他，同时争论他的一个想法。他在电话里跟他说话的时候，另一位将军泡在嘴边，从椅子上掉下来。</p><p>博伊德在他身后留下了很多敌人，因此他最终被提升为晋升将军并不奇怪。冒犯了这么多人，他们拒绝让他加入他们的稀有队伍。博伊德深感失望。但他为自己选择的课程感到自豪。当他走进制度成功与做正确分歧的十字路口时，他选择做正确的事情。这是一种哲学，他会支持他的Acolytes（他的一组受训者），因为他们权衡是否为他工作并帮助做一些重要的事情，但他们的职业生涯因为协会而受到阻碍，或者保持低调并按照自己的方式工作排名靠前。“老虎，”他会说，“总有一天你会来路上岔路口：”</p><p>“你将不得不决定你想去哪个方向。”他举起手指了指。“如果你这样走，你可以成为某个人。你将不得不妥协，你将不得不背弃你的朋友。但是你将成为俱乐部的一名成员，你将获得晋升，你将得到很好的任务。“然后博伊德举起另一只手指向另一个方向。“或者你可以这样做，你可以做点什么 - 为你的国家，你的空军和你自己。如果你决定要做某事，你可能不会升职，也可能没有得到好的任务，你肯定不会成为上司的最爱。但你不必妥协自己。你将忠于你的朋友和你自己。而你的工作可能会有所作为。成为某人或做某事。在生活中经常有唱名。那是你必须做出决定的时候。要做还是做？你会走哪条路？“</p><h2 id="你会走哪条路？"><a href="#你会走哪条路？" class="headerlink" title="你会走哪条路？"></a>你会走哪条路？</h2><p>在每个人的生活中都有一点，他必须决定他是否会努力成为一个重要的人，或者他是否会努力做一些重要的事情。有时这些追求是相辅相成的; 他们经常没有。</p><p>研究已经一次又一次地表明，我们现代的孩子们渴望的是一种被视为更加迷人的生活，而不是服务和持久遗产。事实上，今天5到11岁的人的三大职业抱负是体育明星，音乐明星和演员。就在25年前，同样的调查发现了老师，医生和银行家。年轻人希望得到认可，成名，并且很早就意识到通往名人的道路（更不用说政府服务）主要涉及告诉人们他们想听到什么 - 包装已经流行的东西并将其卖回去。因为它不仅仅是军队对现状的珍惜; 虽然社会被认为比以往任何时候都更加宽容，但从主流中迅速弹出的任何钉子都会受到重创。在我们的数字时代，正义的在线暴徒可以迅速动员和沉默任何被认为是异常的意见。结果是令人不寒而栗的效果，人们必须看到他们所说的每一个字，以免被公开抨击。</p><p>即使是科学领域也无法免受这种趋势的影响。获得一个人的研究不仅发表在学术期刊上，而且在大众媒体出版物中获得可以带来利润丰厚的书籍交易和演讲活动，而研究甚至有一丝争议可能会引发批评的风暴。当揭示一位着名的社会心理学家完全捏造研究时据称，这些东西可能会增加种族主义倾向，但他承认，他会尝试提出看似原创和令人兴奋的实验和结果，同时也会让人们的先入为主的期望得到满足。在解释他的道德失误时，他指出了这样一个事实，即现代科学家在争夺资金和钦佩时，被迫成为研究人员和营销人员 - 劝说艺术方面的“旅行推销员”。这已经形成了有时以牺牲真理为代价来追求承认的情况。</p><p>挑战现状绝非易事。你可能不会担心赢得名声，而只是坚持你的工作。大学生，在培养他们的“个人品牌”的重要性中受过教育，可以理解的是，在经济缓慢的情况下，做任何可能使他们对雇主不太理想的事情都是可怕的。这就是为什么说实话能力的能力一直与对物质安全的冷漠联系在一起。正如科拉姆写的那样，博伊德理解这一点，并说“ 如果一个人可以将他的需求减少到零，那么他就是真正的自由：没有任何东西可以从他身上拿走而且任何人都无法做到伤害他“他的极度节俭为他赢得了”少数民族居住区上校“的绰号，并且在他的一生中，他住在一间小公寓里，把他那些笨重的汽车撞到了地上。斯巴达的这种生活方式对博伊德的家庭来说很艰难; 当谈到冒着生命危险为了晃动船只时，父亲们肯定有更难走的路线。然而，历史上最伟大的煽动者的孩子们尽管牺牲了他们父亲的立场，却为他们遗留下来的遗产和名字感到非常自豪。</p><p>当你在考虑选择追求正确，有意义或受欢迎的决定时，你会想到你会做什么，我们将给你留下前国防部长罗伯特盖茨在空军学院的毕业演讲中给出的这个激动人心的信息。它适用于那天坐在观众席上的学员，就像现在所有阅读它的人一样：</p><blockquote><p>“在空军学院，与美国的每所大学和公司一样，重点是团队合作，建立共识和协作。但不要搞错，当你必须独自做出一个艰难的，不受欢迎的决定时，你们每个人的时间都会到来; 当你必须质疑上级的意见或告诉他们你不能利用现有的时间和资源完成工作时; 或者当你知道上司告诉新闻界或国会或美国人民是不准确的时候。有一段时间你的整个职业生涯都处于危险之中 - 你会在路上面对博伊德的谚语。做或做。</p></blockquote><p>为了做好准备，你必须有纪律从学院这里培养正直和道德勇气，然后从你最早的时候作为一名委任军官。这些品质不会在一夜之间突然出现，也不会在你承担重要责任后作为启示。这些品质源于你在这里和职业生涯早期做出的小决定，必须在整个过程中得到加强，让你在服务前抵制自我的诱惑。而且你必须始终确保你的道德勇气能为更大的利益服务：它为国家和我们的最高价值服务 - 不是特定的计划，也不是骄傲，也不是狭隘主义。“</p><p>点名时间：是或将要做？你会走哪条路？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在： 男人的生活，行动，领导，在男子气概中的教训&lt;/p&gt;
&lt;p&gt;Brett＆Kate McKay • 2014年1月22日 最后更新时间： 2018年12月7日&lt;/p&gt;
&lt;h1 id=&quot;约翰博伊德的唱名表：你想成为某人还是做点什么？&quot;&gt;&lt;a href=&quot;#约翰博伊德的唱名表
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OODA Loop</title>
    <link href="http://s.bixuebihui.cn/2019/08/13/ooda-loop/"/>
    <id>http://s.bixuebihui.cn/2019/08/13/ooda-loop/</id>
    <published>2019-08-13T01:47:49.000Z</published>
    <updated>2019-08-13T02:07:50.944Z</updated>
    
    <content type="html"><![CDATA[<p>Brett＆Kate McKay • 2019年5月2日 最后更新： 2019年5月11日</p><h1 id="博伊德之道：如何掌握OODA循环"><a href="#博伊德之道：如何掌握OODA循环" class="headerlink" title="博伊德之道：如何掌握OODA循环"></a>博伊德之道：如何掌握OODA循环</h1><p>ooda循环图约翰博伊德军事战略家 </p><p><img src="https://content.artofmanliness.com/uploads//2014/09/OODA-Header-2.jpg" alt="OODA"></p><p>编者注：这最初发布于2014年9月14日。我们已经更新了更多资源以供查看。</p><p>约翰博伊德被一些人描述为历史上最伟大的军事战略家，没有人知道。他在朝鲜战争中作为战斗机飞行员开始了他的军事生涯，但他慢慢地将自己变成了有史以来最伟大的哲学家之一。</p><p>1961年，33岁时，他写了“空中攻击研究”，首次编写了最佳的斗狗战术，成为了“空战圣经”，并彻底改变了世界上每一支空军的方法。</p><p>他的  能量可操作性（EM）理论  帮助生产了具有传奇色彩的F-15，F-16和A-10飞机。</p><p>不过，他对军事战略的最重要贡献可能来自他给出的一系列简报。在他们中间，博伊德提出了一种思考冲突的方法，这种冲突将彻底改变全世界的战争。</p><p>这个想法集中在一个令人难以置信的战略工具：OODA循环 - 观察，定位，决定，行动。世界各地的国家甚至恐怖组织都将OODA Loop作为其军事战略的一部分。它也被企业采用，以帮助他们在动荡和竞争激烈的经济中茁壮成长。</p><p>OODA循环是一个经常被引用但通常被误解的想法。如果你已经听说过它，它很可能以一种相当肤浅的方式呈现 - 作为一个四步决策过程，在这个过程中，通过所有阶段最快的个人或团体获胜。这是OODA Loop的一个元素，但还有更多内容。</p><p>OODA Loop经常被误解的原因是John Boyd从未在技术论文中详细描述过它。事实上，尽管他对军事战略做出了很多贡献，但他只有一篇非常简短的文章 - “毁灭与创造”。相反，他通过一系列有时长达五小时的简报来开发和解释OODA循环。我们唯一的笔记是他的简报幻灯片和他的演讲中存在的一些磁带录音和成绩单。（因为他从来没有写下自己的想法，军队和企业经常使用他的想法，而没有给予他信任。缺乏文件可能解释了为什么今天很少有人知道John Boyd。）</p><p>当您浏览这些材料时，您很快就会发现OODA Loop的开发中有很多艰难的思考和哲学思考。博伊德将对军事历史和战略思想的深刻理解与广泛的其他知识领域和定理结合起来，包括量子力学，控制论，混沌理论，波普尔主义和新达尔文主义。因此，要真正了解OODA循环，必须熟悉有助于创建它的科学和哲学发展。</p><p>因此，一旦你超越OODA Loop的简化的Cliff Notes版本，你会发现它实际上非常令人兴奋。在揭示前所未有的洞察力的意义上，它并非“开创性”; 相反，它的力量是明确的，通常是隐含的。它采用了我们在世界中思考，决定和运作的基本方式 - 在冲突和混乱面前经常混淆和混乱的方式 - 并将它们编纂并组织成一个战略性的，有效的系统，可以让你在战斗的热度。这是一个学习系统，一种处理不确定性的方法，以及赢得头对头比赛和比赛的策略。在战争，商业或生活中，OODA Loop可以帮助您应对变化的，具有挑战性的环境，并在另一侧脱颖而出。</p><p>我花了最后一个月潜入OODA Loop - 阅读其中的所有内容，从Boyd的简报到传记，再到其他作者对该理论的分析。我还会见了美国前空军元帅柯特斯斯普拉格和达拉斯联邦空军元帅学校的首席讲师，以及OODA Loop的狂热学生和导师，以获得他的见解。下面你会找到我学到的东西的综合。我的目标是在那里提供OODA Loop上最全面，最易读的入门书。要开始你掌握“博伊德之道”的旅程，请继续阅读。</p><p>查看我的播客与John Boyd简历，Robert Coram</p><h2 id="为什么我们生活在不确定性中"><a href="#为什么我们生活在不确定性中" class="headerlink" title="为什么我们生活在不确定性中"></a>为什么我们生活在不确定性中</h2><p>“模棱两可是博伊德愿景的核心……不是一件值得担心的东西，而是一件给定的东西……我们从来没有完整而完美的信息。成功的最好方法是陶醉于模棱两可。“ - 格兰特哈蒙德，战争之心：约翰博伊德和美国安全</p><p>博伊德认为，模糊和不确定性围绕着我们。虽然外界的随机性在这种不确定性中发挥着重要作用，但博伊德认为，我们无法正确理解我们不断变化的现实是更大的障碍。当我们的情况发生变化时，我们往往没有转变观点，而是继续试图看到我们认为应该存在的世界。我们需要改变博伊德称之为现有的“心理概念” - 或者我称之为“心理模型” - 以便应对新的现实。</p><p>心理模型 - 或范例 - 只是一种观察和理解世界的方式。他们创造了我们对世界运作方式的期望。它们有时是文化相对的，可以植根于传统，遗产甚至遗传学。它们可以是具体的交通法规或社交礼仪。或者它们可以像组织或研究领域的总体原则那样一般，如心理学，历史，科学和数学的规律和理论，以及关于参与规则的军事学说。由于博伊德对使用OODA循环作为大战略的组织原则更感兴趣，他倾向于关注这些更抽象的心理模型类型。</p><p>虽然我们的范例大部分时间都与现实相匹配，但有时却不然。有时宇宙会给我们一个我们从未见过的曲线球，我们必须使用的心理模型并不是真的有用。如果有人跑红灯，或亲吻我们而不是握手，我们很惊讶并暂时抛弃我们的游戏。如果一位考古学家要发现人类在恐龙身边骑行的证据，那么以前关于地球历史的理论就会陷入混乱。</p><p>博伊德指出三个哲学和科学原理，表明试图用预先存在的心理模型来理解随机变化的宇宙只会导致混乱，模糊和更多的不确定性。理解这些原则的基础有助于说明不确定性和模糊性不仅仅是人类理解或逻辑中的错误，而是真正建立在宇宙框架内 - 包括我们自身内外的世界。这三个原则是哥德尔的证明，海森堡的不确定性原理，以及热力学的第二定律：</p><p>哥德尔的不完备性定理。博伊德根据哥德尔的不完全性定理推断，任何现实的逻辑模型都是不完整的（并且可能不一致），并且必须在面对新观察时不断改进/调整。</p><p>然而，随着我们对世界的观察变得越来越精确和微妙，第二个原则开始限制了我们正确观察现实的能力：海森堡的不确定性原则。</p><p>海森堡的不确定性原则。简而言之，这个原则表明我们不能同时确定或确定粒子或物体的速度和位置。我们可以测量这些粒子的坐标或运动，但不能同时测量两者。当我们对一个值（速度或位置）进行越来越精确的测量时，我们对另一个值的测量变得越来越不确定。一个变量的不确定性仅通过观察行为产生。</p><p>应用这一原则来理解我们周围的世界，Boyd推断，即使我们对特定领域进行更精确的观察，我们也可能会遇到更多关于另一个领域的不确定性。因此，我们精确地观察现实的能力存在局限性。</p><p>以柯达为例。尽管该公司今天发明了数码相机中使用的核心技术，但他们如此专注于传统电影，却未能看到数字化的新兴趋势最终会消耗照片行业。通过坚持传统电影永远存在的心理模型，他们错过了景观正在迅速转移的事实，最终导致传说中的公司不得不申请破产。</p><p>2 次热力学定律。 应用热力学第二定律来理解现实，博伊德推断，通过获取有关环境的新信息或通过创建新的心智模型而不与外界交流的个人或组织就像一个“封闭系统”。封闭系统本质上会增加熵或紊乱，如果一个人或组织与外界和新信息隔绝，也会经历心理熵或紊乱。</p><p>即使在我们周围的世界正在发生变化时，我们越依赖过时的心理模型，我们的心理“熵”就越多。</p><p>想想一个与该团其他成员的交流被切断的军队排。孤立的排可能有一个关于敌人所处位置及其能力的想法或心智模型，但自从他们上次谈到命令以来，情况发生了变化。当他们继续使用他们过时的心理模型来应对不断变化的现实时，结果是混乱，混乱和沮丧。</p><p>博伊德从哥德尔的定理，海森堡的不确定性原理和热力学第二定律中获得了见解，并将它们合成为他自己的原则，以便当我们试图将旧的心理模型强加于新环境时会发生什么：</p><p>“总而言之，这三个概念支持这样一种观点，即任何内向型和持续不断努力改善匹配概念与观察到的现实只会增加不匹配的程度。”[强调我的]</p><p>Boyd关于为什么不确定性充足的案例的关键在于个人和组织经常向内看，并应用过去曾经工作的熟悉的心理模型来尝试解决新问题。当这些旧的思维模式不工作，他们往往会继续努力，以使他们的工作 - 也许如果他们只是使用一个更有趣的旧策略，事情将会成功。但他们没有。商业巨头查理芒格称这种倾向即使在面对变化的现实时也会使用熟悉的“有锤子综合症的男人。”你知道古老的说法：“对于只有锤子的男人，一切都是钉子。”所以人们可以与一两个心理模型一起工作。每个问题都可以通过他们当前的思维方式来解决。因此，他们不断抨击，混淆和幻想破灭，他们的工作没有产生任何结果。</p><p>这些人永远不会停下来问，“也许我需要一个不同的工具？”</p><h3 id="博伊德之道：OODA循环"><a href="#博伊德之道：OODA循环" class="headerlink" title="博伊德之道：OODA循环"></a>博伊德之道：OODA循环</h3><p>“这是一种心态，对事物的统一性的学习，对定位哲学和宗教中已知的基本见解的理解仅仅是道路[或道]。对于博伊德来说，道路不是目的，而是一个过程，一个旅程……从不同的角度，从不同的角度，从常规检查相反的命题，以不同的方式审视世界的关系，重要性是重要的。关键是精神敏捷。“ - 甘特哈蒙德</p><p>那么我们如何克服这种不确定性或心理熵呢？约翰博伊德一生都在努力（直到他去世的那天）试图回答这个问题。</p><p>OODA Loop就是结果。</p><p>大多数熟悉OODA Loop的人可能已经看到了这个简单的图表：<br><img src="https://content.artofmanliness.com/uploads//2014/09/OODA-Loop-1-1.jpg" alt="OODA Loop"></p><h2 id="ooda循环例证约翰boyd军事战略"><a href="#ooda循环例证约翰boyd军事战略" class="headerlink" title="ooda循环例证约翰boyd军事战略"></a>ooda循环例证约翰boyd军事战略</h2><p>这是John Boyd的OODA Loop的准确但简化的版本。事实上，Boyd在解释Loop时经常使用这个基本图表，但他对此有一个更宏大的愿景; 它是“自我组织，出现和自然选择的进化，开放，远非均衡过程”的明确表征。</p><p>或者换句话说，OODA循环是人类和组织在快速变化的环境中学习，成长和茁壮成长的过程的明确表示 - 无论是在战争，商业还是生活中。</p><p>在他生命的最后，博伊德绘制了一个更加细致入微的复杂图表，更好地捕捉了他对OODA循环的宏伟，深刻的视野，作为在不断变化和不确定的环境中智力成长和进化的元范式：</p><p><img src="https://content.artofmanliness.com/uploads//2014/09/OODA-Loop-2-1.jpg" alt="ooda循环例证约翰boyd军事战略"></p><p>比简单的四步图复杂得多，是吧？</p><p>对于不熟悉的人来说，博伊德对OODA Loop的全部看法可能看起来像一堆狼吞虎咽。但是，一旦你理解了创建这个图表的思想和哲学思想，你很快就会意识到它是多么富有洞察力和深刻。</p><p>下面，我将带您走过John Boyd的OODA Loop。我的目标是告诉你，它不仅是简单的四步决策工具，它通常被视为，而是在很多方面涛，或思维方式，了解世界，以应对不确定性（或换句话说，生活！）。一旦你理解了博伊德之道，你会发现自己在日常生活中越来越多地使用它。</p><blockquote><p>“如果我们不与外界沟通 - 获取知识和理解的信息 - 我们就会消亡，成为那个世界中一个不具洞察力和无趣的部分。” - 约翰·博伊德</p></blockquote><p>OODA循环的第一步是观察。这是让我们克服热力学第二定律的步骤。通过观察并考虑有关我们不断变化的环境的新信息，我们的思想成为一个开放的系统而不是封闭的系统，我们能够获得对形成新的心理模型至关重要的知识和理解。作为一个开放的系统，我们的定位是克服引起混乱的心理熵。</p><p>从战术的角度来看，要有效地观察你需要具备良好的态势感知能力。你需要始终处于条件黄色。条件黄色最好描述为  放松警报。没有特定的威胁情况，但是你的头抬起，睁着眼睛，你以轻松但警觉的方式接受周围的环境。我计划在今年晚些时候发表关于改善你的态势感知的帖子，但是现在你可以开始做一些事情来改善你的“A-Game”（正如我的朋友Mike Seeklander所说的那样）：</p><p>每当您进入公共建筑时，就开始键入所有出口的位置。如果，天堂禁止，一个人带着枪开火，你想知道他们可能的出入点在哪里，你想知道你最近的出口在哪里。<br>让你身边的人一次过来，并留意看起来似乎不正常的行为。正常将取决于情况和环境（有足够的心理模型对于确定基线行为很重要 - 请参阅下面的“定位” ），因为有人表现得很奇怪并不一定意味着他们是一种威胁。只需将它们放在你的雷达上。<br>从一个重要的战略层面来看，比如说，经营一个成功的企业，观察将要求您不仅要跟踪您的总收入，支出和利润，还要跟踪可能会或可能不会影响您的底线的更大趋势。阅读与您的业务相关的贸易期刊或博客应该是您定期观察的一部分，以及简单地与您自己的行业中的其他业主以及影响您的行业的其他业主交谈。例如，虽然我显然应该对博客有深入的了解，但我还需要了解网络托管，网络中立性以及其他更多技术问题，这些问题最终会影响AoM的运行和运营方式。</p><p>在他的演讲中，Boyd指出我们在观察阶段会遇到两个问题：</p><p>我们经常观察到不完整或不完整的信息（归功于海森堡的不确定性原理）<br>我们可以充斥着如此多的信息，以至于难以将信号与噪声分离<br>通过发展我们的判断 - 我们的实践智慧来解决这两个陷阱。正如John Boyd的学者Frans PB Osinga在“ 科学”，“战略”和“战争 ”中所指出的那样，“即使一个人拥有完美的信息，如果它没有与对其含义的深入理解相结合，如果没有人看到这些模式，那就毫无价值。判断是关键。没有判断，数据就没有意义。它不一定是有更多信息的人将获得胜利，它是一个具有更好判断力的人，更善于辨别模式的人。“</p><p>我们如何发展这种判断，以便我们更好地理解我们的观察结果？通过成为OODA Loop下一步的灵巧实践者：定位。</p><p>定位：环路的Schwerpunkt<br>OODA Loop中最重要的一步是定位，但经常被忽视的一步。博伊德称这一步为schwerpunkt（他从德国闪电战中借来的一个词），或循环的焦点。</p><p>定位是OODA Loop 的schwerpunkt的原因是因为这是我们的心理模型存在的地方，而我们的心理模型决定了OODA循环中的所有东西的运作方式。正如奥辛加所说，“取向塑造了我们与环境互动的方式……它塑造了我们观察的方式，我们决定的方式，我们的行为方式。从这个意义上讲，方向塑造了当前OODA循环的特征，而现在的循环塑造了未来方向的特征。“</p><p>那么，如何在快速变化的环境中定位自己呢？</p><p>你经常不得不拆开旧的范例，把最终的部分重新组合在一起，创造出一个更符合当前现实的新视角。</p><p>Boyd将这个过程称为“ 破坏性演绎”。当我们这样做时，我们分析并将我们的心理概念分解为不连续的部分。一旦我们拥有了这些构成要素，我们就可以开始“ 创造性归纳 ” 的过程- 利用这些旧的碎片形成新的心理概念，这些概念与我们观察到的真实情况更加紧密地联系在一起。</p><p>为了说明这个过程，博伊德在一个名为“ 战略游戏”的演讲中提出了这个思想实验。和？（他在本演讲的工作笔记中确实有问号，而且在他的职业生涯中从未填写过他们的问题）：</p><p>“想象一下，你和其他滑雪者一起坐在滑雪场上……你在佛罗里达州乘坐舷外摩托艇，甚至可以拖着水上滑雪者。想象一下，你在一个美好的春日骑自行车。想象一下，你是一个父母将你的儿子送到百货公司，你注意到他对玩具拖拉机或带橡皮履带的坦克着迷。</p><p>现在想象一下你把滑雪板拉下来但你还在滑雪坡上。想象一下，你从摩托艇上拆下舷外马达，你不再在佛罗里达州了。然后从自行车上取下把手并丢弃自行车的其余部分。最后，你从玩具拖拉机或坦克上取下橡胶踏板。这只留下以下各个部分：滑雪板，舷外发动机，车把和橡胶踏板。“</p><p>博伊德然后挑战他的观众想象当你把这些特定部分组合在一起时会出现什么。</p><p>你明白了吗？</p><p>这是一辆雪地摩托车。</p><p>简而言之，定位是能够在飞行中和面对不确定性的情况下制作具象的心理雪地摩托车。</p><p>博伊德认为，有效定位的能力是在任何冲突中将胜利者与输家分开的原因：</p><p>“失败者是指在面对不确定性和不可预测的变化时无法制造雪地车的人（个人或团体）; 而获胜者是指某人（个人或团体）可以制造雪地摩托车，并在面对不确定性和不可预测的变化时以适当的方式使用它们。“</p><p>重要的是要指出演绎破坏和心理模型的创造性归纳不是一次性事件。对于博伊德来说，这是一个持续的过程 ; 一旦你创造了新的心理概念，它就会很快变得过时，因为你周围的环境会发生变化。</p><p>因此，如果Orientation是成功实施OODA Loop的关键，那么我们如何才能更好地实现它？</p><p>博伊德给我们留下了一些想法：</p><p>1.构建一个强大的心理模型工具箱。</p><p>您拥有的心理模型越多，您在创建新模型时就越需要。在1992年空军战争学院的一次演讲中，博伊德警告他的观众，严格的操作学说可以扼杀强大的心智模型工具箱的培养方式：</p><p>“空军有一个学说，陆军有一个学说，海军有一个学说，每个人都有一个学说。[但如果你]读了我的作品，’教条’就不会出现在那里。你找不到它。你知道为什么我没有它吗？因为它是第一天的教义，也是它成为教条之后的每一天。这就是为什么…。”</p><p>教条倾向于强化教条，教条主义倾向于创造“有锤子综合症的人”的人 - 它使人们不断尝试应用同样的旧心理模型，即使它不再适用于不断变化的环境。即使市场正朝着另一个方向发展，你仍然会看到那些坚持经过考验的商业模式的企业“有锤子综合症的人”。如上所述，柯达就是一个很好的例子。Blockbuster也是如此。他们继续将硬拷贝电影租赁作为其业务的主要部分，尽管越来越多的消费者通过互联网流媒体电影。百视达最终试图改变他们的商业模式，但它太少，太晚了。</p><p>在发现一些宠物理论并开始将其应用于每个人的人们中，你也会看到“有锤子综合症的人”。单。生活中的情况没有考虑其他因素。那些喜欢进化心理学的人很容易这样做。对他们来说，所有的人类行为都可以用它来解释。为什么男人比女人更嫉妒？因为在原始时代，他们无法知道他们是否真的是婴儿的父亲。为什么我们会感到沮丧？它曾经帮助人们专注于他们的问题，并找出如何摆脱困境。虽然我们的进化心理学在我们的行为中肯定起着重要作用，但其他因素也与我们为什么做我们的行为有关。折扣那些是愚蠢的。</p><p>正是因为这个原因，博伊德主张尽可能多地熟悉自己的理论和知识领域，并继续挑战你的信念，即使你认为你已经弄明白了：</p><p>“好吧，我知道你将不得不写[军事]学说，这没关系…… [但]即使你写完之后，也认为这是不对的。看看其他许多学说 - 德国学说，其他学说 - 并学习它们。然后你有了很多学说，而且你想要学习它们的原因[就是这样]你没有被任何人捕获，你可以把东西从这里拿出来，把东西拿出来…… 你可以把你的雪地摩托车放在一起，你做得比其他任何人都好。如果你有一个学说，那你就是恐龙。期。”</p><p>我们在指尖上拥有的理论或心理模型越多，我们用来构建我们的具象雪地摩托车的材料就越多。</p><p>Charlie Munger在1994年在南加州大学商学院的一次演讲中提出了一个类似的论点，即必须拥有一个广泛多样的心理知识库：</p><p>“你必须拥有模特。而且你必须在模型的这个格子工作中体验你的经验 - 代理和直接。你可能已经注意到那些只是试图记住并重新记住所记忆的人的学生。好吧，他们在学校和生活中失败了。你必须把经验挂在头脑中的模型格子上。有哪些型号？嗯，第一个规则是你必须拥有多个模型 - 因为如果你只有一两个你正在使用的模型，那么人类心理学的本质就是你会折磨现实以使它适合你的模型，或者至少你会认为它… 所以你必须有多个模型。模型必须来自多个学科 - 因为世界上所有的智慧都不是在一个小学术部门中找到的。”</p><p>芒格在演讲中一再强调，现实是一个相互影响的因素相互关联的生态系统。因此，要了解这个生态系统，您需要以互连的方式应用多个模型。约翰缪尔说得最好：“当我们试图自己挑选任何东西时，我们发现它与宇宙中的其他一切联系起来。”</p><p>因此，所有关于拥有多个心理模型的讨论都会引发一个问题：您应该在工具箱中放置哪种模型？</p><p>博伊德和芒格都提出了一些建议。在他的战略游戏介绍中？和？博伊德列出了七个学科，每个军事战略家（或任何策划如何赢得任何冲突或竞争的人）都应该知道：</p><ul><li>数学逻辑</li><li>物理</li><li>热力学</li><li>生物学</li><li>心理学</li><li>人类学</li><li>冲突（博弈论）</li></ul><p>博伊德强调，他的名单当然不是详尽无遗的，也应该追求其他心理概念。在其他演讲中，博伊德暗示生物进化和量子力学是每个主要战略家都应该掌握的额外心理模型。</p><p>芒格的名单包括以下心理模型：</p><ul><li>数学（芒格特别喜欢反演的代数思想，即解决你向后解决的问题）</li><li>会计（及其限制）</li><li>工程（根据Munger，冗余和断点的想法适用于工程之外，可以应用于业务）</li><li>经济学</li><li>概率</li><li>心理学（特别是导致我们做出糟糕决定的认知偏见）</li><li>化学</li><li>进化生物学（可以提供经济学的见解）</li><li>历史</li><li>统计</li></ul><p>我个人会将哲学，文学（及其附带的解释模型）和基本的普通法原则（如侵权法，合同法和财产法）添加到清单中。</p><p>因为博伊德和芒格正在思考“大图”，他们的心理模型例子是有目的的一般性和抽象性的。但重要的是要记住，心理模型可以具体而具体。为了在你的工作中茁壮成长，你需要一些特定于你职业生涯的心理模型。为了在致命的遭遇中生存，你需要某些特定于战术情境的心理模型。尽可能多地学习心理模型，并尽可能详尽地创建格子工作，这样您就可以在创建和销毁过程中有更多工作。</p><p>对于没有经验的人来说，其中一些主题肯定会令人生畏。要开始，请查看我们关于终身学习的文章中的资源部分- 尤其是在线课程。例如，Coursera有许多关于微积分，经济，竞争策略等的入门课程。</p><p>2.开始摧毁和创建心理模型。</p><p>你在摧毁和创造心理模型方面的流畅性只会随着练习而来，所以尽可能多地开始练习。当你遇到一个新问题时，以类似清单的方式浏览上面的域名并问自己：“这些不同的心理概念中是否存在可以提供我的问题洞察力的元素？”</p><p>也许有一个来自工程学，柏拉图和生物学的原理，可以帮助创造一个与你的新现实相匹配的新的心理模型。</p><p>通过破坏和创建实验开始日记。通过书写和涂鸦来消除新的心理概念。您可能会对此练习中获得的见解感到惊讶。</p><p>当你练习摧毁和创建心理模型时，你会发现它会变得更容易，更容易。它几乎是直观的。在掌握中，罗伯特·格林（ Robert Greene）将历史上伟大的军事战略家描述为知道如何在战场上行进的“指尖感觉”。这些伟大的战略家在定位方面非常有效和高效。他们没有刻意思考这个过程，他们只是这样做了。这应该是你的目标。</p><p>3.永远不要停止定向。</p><p>“定位不仅仅是你所处的状态; 这是一个过程。你总是在定位。“ - 约翰博伊德</p><p>因为你周围的世界在不断变化，所以你可以永远不会停止这种定位。“ABO =永远定位”应该成为你的口头禅。让它成为每天添加到心理模型工具箱中的目标，然后立即开始雾化这些模型并制作新模型。</p><p>4.尝试在操作前验证心智模型。</p><p>理想情况下，根据Boyd的说法，您希望相信您的心智模型或概念在您真正需要使用它们之前是可行的。在战斗或生死攸关的情况下尤其如此，其中OODA循环的快速循环是至关重要的（更多关于节奏下面）。</p><p>如何在手术前验证心智模型？您研究心理概念在类似情况下有哪些功能，哪些功能无效，然后使用这些心理概念进行练习，训练和可视化。想想篮球队输掉比赛一篮子的情况，时间还剩下几秒钟，而且他们正在进球。他们已经花了数周时间练习针对这些特定情况设计的特定游戏，现在他们只需执行该计划。</p><p>即使在时间不重要的情况下，现场测试的心理概念也很重要。在商业中，您可以阅读有关其他公司有效和无效的案例研究，并准备好您可以在类似情况出现时立即实施的模型，概念和策略。当然，如果那些不起作用，你需要继续定向过程，直到你创建一个更适合这种情况的新心理模型。</p><p>当您对环境的观察与某些经过验证的心理模型相匹配时，您不必进行任何破坏和创建，您只需采取行动即可。如果你看一下上面循环的复杂图表，你会注意到Boyd为跳过“决定”步骤的能力留出了空间 - 注意从“Orient”到“Act”的行并绕过“Decide”。 Boyd称能够快速定位并采取行动，“隐含结果和控制。”这与Greene所说的“指尖感觉”类似。在特定领域取得掌握的人应该能够快速注意到现实与特定心理模型对齐，然后执行该心理模型而无需做出决定。你只是行动。</p><p>我不能足够努力地回家定位步骤的重要性。它是OODA Loop的核心，也是决定您成功实施它的原因。如果你不使用最接近环境的心理模型，那么无论你在循环中循环多快，你都会失败。</p><p>ABO =始终定位。</p><p>决定（假设）<br>Boyd没有对决策步骤做出太多阐述，只不过它是“ 参与者决定在迎新阶段产生的行动选择的组成部分”。</p><p>对于博伊德来说，选择一个完美匹配的心理模型是不可能的，因为：</p><p>我们经常有不完整的环境信息<br>即使我们有完美的信息，海森堡的不确定性原则也阻止我们在环境和心理模型之间达到完美匹配<br>因此，当我们决定使用哪种心理模型时，我们不得不接受那些不完美但又足够好的模型。</p><p>值得注意的是，在他最后的OODA Loop草图中，Boyd将“假设”放在“决定”旁边的括号中，表明我们决策的不确定性。当我们决定的时候，我们基本上都在推进我们最好的假设 - 我们最好的“有根据的猜测” - 关于哪种心理模型可行。为了确定我们的假设是否正确，我们必须对其进行测试，这将我们带到下一步：</p><p>行动（测试）<br>一旦你决定实施心理概念，你必须采取行动。在他最后的OODA Loop草图中，Boyd在“Act”旁边有“Test”，再次表明OODA Loop不仅是一个决策过程，而且是一个学习系统; 我们都像科学家一样，在现实世界中不断测试我们的新假设。我们都应该不断地“试验”，并获得新的“数据”，以改善我们在生活的各个方面的运作方式。正如Osinga在“ 科学”，“战略”和“战争 ”中指出的那样，行动“反馈到系统中，作为对现有定向模式的正确性和充分性的有效性检查。”</p><p>行动是我们如何发现我们的心理模型是否正确。如果他们是，我们赢得了战斗; 如果不是，那么我们使用我们新观察到的数据再次启动OODA循环。</p><p>理想情况下，您将同时进行多个动作/测试/实验，以便您可以快速发现特定情况下的最佳心理模型。在战争中，这可能意味着有多个使用不同武器系统的攻击点。当战略家发现哪些目标和武器提供了最好的结果时，他会将注意力集中在获胜的心智模型上并将其利用到最大程度，直到它不再有效。一旦他观察到它不再有效，他就会定位更多的心理概念，决定使用其中的一个或几个，并迅速采取行动来测试它们。这个过程一遍又一遍，直到敌人被淘汰出局。</p><p>业务也是如此。理想情况下，您需要同时尝试不同的策略以查看哪些策略有效。A / B测试就是一个很好的例子。在A / B测试中，营销人员或在线出版物将提出多个标题或副本（方向！），并同时将其部署在其受众的不同部分。然后他们会坐下来观看哪个标题，消息等表现最佳。无论哪个标题获得最多点击，都将成为默认值。</p><blockquote><p>“我们必须在头脑中获得图像或图片，我们称之为方向。然后我们必须决定我们要做什么，然后实施决定……然后我们看看[结果]行动，加上我们的观察，然后我们拖入新数据，新方向，新决策，新动作，无限广告……“ - 约翰博伊德</p></blockquote><p> 节奏：轻快地参加比赛 </p><blockquote><p>“根据OODA循环理论，每个战斗员都会观察情况，定位自己……决定做什么然后去做。然而，如果他的对手可以更快地做到这一点，那么他自己的行为就会过时并与真实情况脱节，而他的对手的优势也会在几何上增加。“ - 约翰博伊德</p></blockquote><p>在这篇文章中，我们一直在谈论OODA循环，主要是作为一种学习系统，可以在任何不确定的情况下使用，以便找出最佳的行动方案和如何进行。它可以指导我们的个人行为，并且不需要“对手”本身才能有用。</p><p>但是这个工具也可以用在冲突和竞争的情况下，那就是你的OODA Loop正在与其他人进行正面交锋。实际上，这就是OODA Loop最着名的用途。每个人或团体都试图比竞争对手更快更有效地通过环路。</p><p>因此，了解OODA Loop如何工作的基本原理还不足以成功实现它。速度也是一个重要的基本要素。</p><p>当我遇到前美国空军元帅和导师Curtis Sprague时，他告诉我在考虑节奏和OODA Loop时要记住两个一般原则。</p><p>首先，能够比对手更快地通过成功的连续OODA循环的个人或组织将赢得冲突。</p><p>其次，快速的OODA循环会让你的对手的OODA循环“重置”造成混乱 - 它会将它们送回原点 ; 回到观察阶段; 回到弄清楚如何继续。这种延迟让你有更多的时间在对手之前完成你的OODA循环。例如，当博伊西州立大学在2007年嘉年华碗期间淘汰了三个特技剧 - 钩 - 侧，自由女神像和中卫折腾 - 它重置了俄克拉荷马大学的OODA循环（以及整个过程）更快的国家）; OU陷入了脚步，无法快速重新定位以超越野马队的激增。</p><p>为了表明当你的OODA Loop与另一个人发生冲突时控制你的节奏至关重要，柯蒂斯指着我们见面的咖啡店门口，问我：“如果有枪的家伙来了，你会怎么做？穿过那扇门？“</p><p>我：“呃……”</p><p>“你死定了。你陷入了定位步骤。你需要有一个你知道的计划足以在那种情况下工作并立即实施。记住，你必须在坏人完成他之前完成你的循环。“</p><p>那么在那种情况下最好的心理模型是什么？根据柯蒂斯的说法，以及对过去主动枪击事件的研究（或正如格罗斯曼中校所说的那样积极谋杀），最好的反应不是逃离或躲避枪手，而是立即缩小你们之间的差距和他一起使他失去能力。事实上，这就是国土安全部在射手相对接近你时的建议。</p><p>为什么这样做？当你立即追捕射手时，你正在搞乱他的计划和他对世界的定位。你进入他的OODA循环，或者正如柯蒂斯所说，你正在“重置它”：</p><p>“大多数暴力枪手都认为，因为他们拥有枪支，人们会做他们所说的，只会隐藏。他们不希望有人跟他们收费。通过缩小差距，您将重置对手的循环，因为现在他们必须重新定位环境中的意外变化。你让他们有一个’呃……’的时刻。通过引起重置，你已经减慢了他的速度，即使它只是几秒钟，这让你有更多的时间来完成你的 OODA循环并赢得战斗。“</p><p>为了让你以这种速度实现心理模型，你必须练习它。柯蒂斯说：“身体不能去大脑没有的地方。” “ 如果你想在现实生活中实现它，你需要练习并想象自己在活跃的射击场景中缩小差距。如果你不这样做，你最终会结冰。“</p><p>所以你的OODA循环快速骑行可以让你进入或重置你的对手，这可以让你先完成你的循环并赢得战斗。OODA循环中的速度是相对的。你必须比你竞争的人更快。</p><p>但是，尽可能快地在你的OODA循环中骑行是一个不完整的节奏画面。研究OODA Loop的人常常忽略的是，当Boyd谈到快节奏时，他经常意味着节奏的快速变化。他认为，在赢得竞争或冲突时，我们的行动需要令人惊讶，模棱两可，变化多端; 快速和不规则地加速和减慢你的行动可能会产生混乱，有时甚至不仅仅是吹过你的OODA循环。如果敌人期待你的突然和快速的攻击，但你反而延迟，你可能会让你的敌人有一个可以被利用的“呃……”时刻。</p><p>更重要的是，当你从战地靴战术层面转向更大的战略层面时，博伊德不太重视快速的OODA循环，而是专注于开发可能赢得战斗或战争的最佳心理概念。正是在这个“大局”层面，当一个战略家正在玩长期游戏时，他会考虑政治，文化，经济，外交和间谍等领域。在这个漫长的游戏中，他完成OODA循环的时间间隔变得更长。他仍然需要在敌人或竞争对手之前完成他的战略循环，但与实际参与战斗的步兵相比，他有更长的时间来完成它。</p><p>结论<br>OODA循环明确了我们隐含的决策过程。通过明确表示，博伊德为从士兵和军队到企业和运动队，社会运动领导者和政治活动家的每个人提供了无与伦比的战略工具，以更好地管理他们自己的决策过程。它还允许操纵和控制竞争对手的决策过程。控制你自己和敌人的OODA循环可以让你脱离征服者。除了作为征服敌人的工具之外，OODA Loop还是一个学习引擎，允许个人或组织在不断变化的环境中茁壮成长。</p><p>自从我开始研究OODA Loop以来，我已经在很多领域获得了新的见解。通过了解暴力对抗成功的关键是更快地通过你的OODA循环并重置坏人的循环，每当我出去的时候，我总是在“思考”如果突然出现一些不好的家伙会怎么做出现了。我接受了詹姆斯·马蒂斯将军对海军陆战队的建议：“要有礼貌，要专业，但要有计划杀死你遇到的每个人。”</p><p>了解OODA Loop也帮助我对我的业务更具战略性。在线出版是一个相对较新的行业，支持它的技术总是在变化。为了茁壮成长，我需要通过警惕的观察来了解行业趋势，然后通过有效的方向定期更新我的心理模型。（你说的是什么？写一些关于像OODA Loop这样的帖子直接面对有利于短声音的在线发布趋势的帖子？啊，但是你看到我正在玩长游戏（没有双关语意） - 我要重置整个互联网的OODA循环。我只是在开玩笑。或者是我？Bwahahaha！）</p><p>我甚至可以应用OODA循环来更好地了解时事。利用ISIS了解乌克兰或中东地区的情况。普京（入侵一个主权国家）和伊斯兰国（斩首记者等）的行动导致美国和其他西方国家有一个“呃……”的时刻。普京和伊斯兰国通过快速和意外的行动有效地重置了美国的OODA Loop。普京有效地采用了不可预测的节奏 - 快速移动，或说大胆的事情，然后出现退缩。西方政治家和军队不得不提出新的心理模型或战略，以便如何应对一个强大的国家入侵另一个国家，以及需要弄清楚如何回应一个想要从顶部悬挂国旗的无形恐怖组织白宫 正如一些Joe Schmo，</p><p>不要被OODA Loop的简单性所迷惑 - 它具有改变你生活的力量和潜力。当你开始通过Loop的镜头看你的生活时，你将获得有关如何取得成功的见解，否则你将无视。按照博伊德的道，你就可以做一些这辈子不只是要有人。</p><p>进一步阅读与OODA循环相关的AoM<br>使用心智模型做出更好的决策</p><p>论大战略</p><p>战略与批判性思维</p><hr><p>资料来源：</p><p> 弗兰斯的科学，战略和战争 PB Osinga（约翰博伊德工作的最佳资源。它很昂贵，但如果你真的想深入研究OODA Loop的开发，那就必须阅读。</p><p>战争的思想：约翰·博伊德和美国的安全  由格兰特·哈蒙德</p><p>博伊德：罗伯特科拉姆改变战争艺术的战斗机飞行员</p><p>远景如此高贵的丹尼尔·福特</p><p> 黑马战术的Curtis Sprague。他对如何在战术环境中应用Loop的见解是非常宝贵的。</p><p><a href="https://www.artofmanliness.com/articles/ooda-loop/" target="_blank" rel="noopener">https://www.artofmanliness.com/articles/ooda-loop/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Brett＆Kate McKay • 2019年5月2日 最后更新： 2019年5月11日&lt;/p&gt;
&lt;h1 id=&quot;博伊德之道：如何掌握OODA循环&quot;&gt;&lt;a href=&quot;#博伊德之道：如何掌握OODA循环&quot; class=&quot;headerlink&quot; title=&quot;博伊德之道：如
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring Cound 源码探密</title>
    <link href="http://s.bixuebihui.cn/2019/08/07/spring-cloud-source/"/>
    <id>http://s.bixuebihui.cn/2019/08/07/spring-cloud-source/</id>
    <published>2019-08-06T23:35:25.000Z</published>
    <updated>2019-08-09T15:12:32.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要看源码"><a href="#为什么要看源码" class="headerlink" title="为什么要看源码"></a>为什么要看源码</h1><ol><li>因为源码获得很容易, 代码本身是最准确的讲解</li><li>推测的结论不准</li><li>“实验”周期长,代价大</li><li>通过查看历史版本差异, 了解功能演化</li><li>源码面前,了无秘密</li></ol><h1 id="下载源码方法"><a href="#下载源码方法" class="headerlink" title="下载源码方法"></a>下载源码方法</h1><p>直接点 CTRL + 类, 通常是编译的内容, 可以在不下载源码时简单看一下, 但有时编译效果不好, 也没有注释说明等. 这时最好是下载源码.</p><p>IDE 中都有相应功能, IDEA 和 eclipse 都有相应功能<br>IDEA 中下载源码 [Download Sources], 可以只下载某个 jar 包对应的源码.</p><p><img src="https://segmentfault.com/img/bVbmZUC" alt="图片描述"></p><p>命令行方式可以一次下载全部源码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    mvn dependency:sources</span><br><span class="line">    ...</span><br><span class="line">    Downloading from ssllrepo: http://dev.myrepo.com/artifactory/repo/com/fasterxml/classmate/1.3.4/classmate-1.3.4-sources.jar</span><br><span class="line">    Downloaded from ssllrepo: http://dev.myrepo.com/artifactory/repo/com/fasterxml/classmate/1.3.4/classmate-1.3.4-sources.jar (48 kB at 694 kB/s)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下载的代码会保存到本地 maven 库里, 即`$&#123;user.home&#125;/.m2/repository` 下</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看源码先要了解模块全图, 了解原理</span><br><span class="line"></span><br><span class="line">核心功能:</span><br><span class="line"></span><br><span class="line"> 1. Distributed/versioned configuration</span><br><span class="line">    </span><br><span class="line"> 1. Service registration and discovery</span><br><span class="line">    </span><br><span class="line"> 1. Routing</span><br><span class="line">    </span><br><span class="line"> 1. Service-to-service calls</span><br><span class="line">    </span><br><span class="line"> 1. Load balancing</span><br><span class="line">    </span><br><span class="line"> 1. Circuit Breakers</span><br><span class="line">    </span><br><span class="line"> 1. Global locks</span><br><span class="line">    </span><br><span class="line"> 1. Leadership election and cluster state</span><br><span class="line">    </span><br><span class="line"> 1. Distributed messaging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 看源码要注意的问题</span><br><span class="line"></span><br><span class="line">1. 要从结构上把握,胸中要有全景图</span><br><span class="line">1. 要从需求出发, 知晓作者是在解决一个什么问题</span><br><span class="line">1. 重点是作者为什么是这么解决的,好处,坏处,如何取舍的</span><br><span class="line">1. 你的时间很宝贵, 不要过度纠缠, 通过源码能解决你的疑问</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 最好带着问题去看</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 问题1: 有哪些配置选项</span><br><span class="line"></span><br><span class="line">https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html</span><br><span class="line"></span><br><span class="line">配置举例：</span><br><span class="line">三种方式</span><br></pre></td></tr></table></figure><p> application.properties 或 application.yml 或命令行选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">配置项</span><br><span class="line"></span><br><span class="line">```ini</span><br><span class="line"></span><br><span class="line">    # REMOTE DEVTOOLS (RemoteDevToolsProperties)</span><br><span class="line">    spring.devtools.remote.context-path=/.~~spring-boot!~ # Context path used to handle the remote connection.</span><br><span class="line">    spring.devtools.remote.proxy.host= # The host of the proxy to use to connect to the remote application.</span><br><span class="line">    spring.devtools.remote.proxy.port= # The port of the proxy to use to connect to the remote application.</span><br><span class="line">    spring.devtools.remote.restart.enabled=true # Whether to enable remote restart.</span><br><span class="line">    spring.devtools.remote.secret= # A shared secret required to establish a connection (required to enable remote support).</span><br><span class="line">    spring.devtools.remote.secret-header-name=X-AUTH-TOKEN # HTTP header used to transfer the shared secret.</span><br></pre></td></tr></table></figure><p>对应的Java类<br><a href="https://github.com/spring-projects/spring-boot/blob/v2.1.2.RELEASE/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/autoconfigure/RemoteDevToolsProperties.java" target="_blank" rel="noopener">RemoteDevToolsProperties.java</a></p><p>管方的 Java 包会在通过<code>META-INF</code>目录下的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring-autoconfigure-metadata.properties</span><br><span class="line">spring-configuration-metadata.json</span><br></pre></td></tr></table></figure><p>例如:<br>~/.m2/repository/org/springframework/boot/spring-boot-autoconfigure/2.0.3.RELEASE/spring-boot-autoconfigure-2.0.3.RELEASE.jar!/META-INF/spring-configuration-metadata.json</p><pre><code class="json">{  <span class="attr">"hints"</span>: [    ...,    {      <span class="attr">"name"</span>: <span class="string">"spring.datasource.data"</span>,      <span class="attr">"providers"</span>: [        {          <span class="attr">"name"</span>: <span class="string">"handle-as"</span>,          <span class="attr">"parameters"</span>: {            <span class="attr">"target"</span>: <span class="string">"java.util.List&lt;org.springframework.core.io.Resource&gt;"</span>          }        }      ]    },    {      <span class="attr">"name"</span>: <span class="string">"spring.datasource.driver-class-name"</span>,      <span class="attr">"providers"</span>: [        {          <span class="attr">"name"</span>: <span class="string">"class-reference"</span>,          <span class="attr">"parameters"</span>: {            <span class="attr">"target"</span>: <span class="string">"java.sql.Driver"</span>          }        }      ]    },    ...    }</code></pre><p>JSON 结构比较简单, 容易看懂.<br>在这个文件里定义了相应的配置项,数值类型,以及可能的备选项进行描述, 从而使得 IDE 可以透过代码提示, 方便用户键入.</p><h2 id="问题2-最小原型是什么"><a href="#问题2-最小原型是什么" class="headerlink" title="问题2: 最小原型是什么"></a>问题2: 最小原型是什么</h2><h2 id="问题3-如何调试"><a href="#问题3-如何调试" class="headerlink" title="问题3: 如何调试"></a>问题3: 如何调试</h2><h2 id="问题4-如何模拟服务失败-模拟容错"><a href="#问题4-如何模拟服务失败-模拟容错" class="headerlink" title="问题4: 如何模拟服务失败, 模拟容错"></a>问题4: 如何模拟服务失败, 模拟容错</h2><h2 id="问题5-如何负载均衡"><a href="#问题5-如何负载均衡" class="headerlink" title="问题5: 如何负载均衡"></a>问题5: 如何负载均衡</h2><h2 id="问题6-如何进行压力测试-模拟熔断"><a href="#问题6-如何进行压力测试-模拟熔断" class="headerlink" title="问题6: 如何进行压力测试, 模拟熔断"></a>问题6: 如何进行压力测试, 模拟熔断</h2><h2 id="问题7-如何自动布署"><a href="#问题7-如何自动布署" class="headerlink" title="问题7: 如何自动布署"></a>问题7: 如何自动布署</h2><h1 id="用测试代码验证自己的想法"><a href="#用测试代码验证自己的想法" class="headerlink" title="用测试代码验证自己的想法"></a>用测试代码验证自己的想法</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么要看源码&quot;&gt;&lt;a href=&quot;#为什么要看源码&quot; class=&quot;headerlink&quot; title=&quot;为什么要看源码&quot;&gt;&lt;/a&gt;为什么要看源码&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;因为源码获得很容易, 代码本身是最准确的讲解&lt;/li&gt;
&lt;li&gt;推测的结论不准&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="spring cloud source code" scheme="http://s.bixuebihui.cn/tags/spring-cloud-source-code/"/>
    
  </entry>
  
</feed>
